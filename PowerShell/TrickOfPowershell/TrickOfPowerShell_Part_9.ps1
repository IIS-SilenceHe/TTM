# Reference site: http://powershell.com/cs/blogs/tips/
###########################################################################################################################################################################################

# Tip 1: Replace Escape


# There are two ways for replacing text, and both have their advantages and pitfalls:

"Hello Silence".Replace("Silence","World")     # Output: Hello World

"Hello Silence".Replace("silence","World")     # Output: Hello Silence

# Unfortunately, as you can see, the method is case-sensitive, and there is no way to change that.

# Alternatively, you can use the -replace operator which is not case sensitive:

"Hello Silence" -replace "Silence","World"                      # Output: Hello World
"Hello Silence" -replace "silence","World"                      # Output: Hello World

# However, the operator -replace really takes a regular expression, 
# and if your replace word contains one of the reserved regex keywords, all breaks or produces wrong results:

"btxtfile.txt" -replace ".txt",".bat"                           # Output: .batfile.bat

# The "." really is a placeholder that represents any character which is why -replace also replaced the beginning of the file name.


# To make -replace a simple operator that only takes plain text, simply escape your text like this:

"btxtfile.txt" -replace [Regex]::Escape(".txt"),".bat"          # Output: btxtfile.bat

# Once you do that, you can safely use -replace without having to worry about regex specialties. it does for all regex-capable operators such as -match, -replace and -split

###########################################################################################################################################################################################

# Tip 2: Use Select-String For Fast Textfile Parsing


# Select-String is an extremely useful cmdlet for parsing log files. You can use it to dump all lines in a text file that contain a certain keyword. 

# This dumps all lines from windowsupdate.log with the keyword "successfully installed":
Select-String -Path C:\Windows\WindowsUpdate.log -Pattern "successfully installed"

# You can also ask Select-String to find lines above or below. 

# uses output generated by ipconfig.exe and lists all lines with "IPv4" plus the line following:

ipconfig | Select-String IPv4                     
# Output: 
#        IPv4 Address. . . . . . . . . . . : 192.168.0.1

ipconfig | Select-String IPv4 -Context 0,1
# Output:
#   >    IPv4 Address. . . . . . . . . . . : 192.168.0.1
#        Subnet Mask . . . . . . . . . . . : 255.255.255.0


# And you can use the results in an object-oriented way. 

# This will find all updates recently installed (if you don't receive anything, then your computer may not have installed any updates lately):

Select-String -Path C:\Windows\WindowsUpdate.log -Pattern "successfully installed" | ForEach-Object {

    $info = $_ | Select-Object -Property Date,LineNumber,Product

    $parts = $_.Line -split "\t"         # take line and split it at tabulators

    # create Date and Time
    # first tab-separated part contains date
    # second tab-separated part contains time
    # take only first 8 characters and omit milliseconds
    [DateTime]$info.Date = $parts[0] + " " + $parts[1].Substring(0,8)

    # extract product name which always follows after 'following update: ':
    $info.Product = ($_.Line -split "following update: ")[-1]

    $info

} | Out-GridView

# The previous approach with Select-String is almost 10x faster than reading the file line by line and doing the filtering manually with Where-Object

###########################################################################################################################################################################################

# Tip 3: Preventing Direct Function Calls


# If you must make sure that a function within your script is inaccessible from outside calls, you can use this trick. Save this code as a script file, then run it:

$scriptPath = $MyInvocation.MyCommand.Definition

function Test
{
    if($MyInvocation.ScriptName -ne $Script:scriptPath)
    {
        Write-Host "Direct call not allowed" -ForegroundColor Red
    }

    "OK"
}

Test

# The function "Test" works just fine when called from within your script. 
# However, when you try and call the function interactively or from within another script, it refuses to run with a red message.

# Typically, when you run scripts non-dot-sourced, all functions within a script remain invisible for the outside caller, so this trick isn't necessary. 
# However, if the user runs the script dot-sourced (by calling it with a dot) or inside the ISE editor, any function defined by the script can be called.

# The code above determines the current script path (which is why the example only works once you save it as a script) and stores this in a script-global variable. 
# The function then checks whether the caller was the same script. If not, it refuses to run.

###########################################################################################################################################################################################

# Tip 4: Reversing GUIDs


# Active Directory and other services sometimes use a custom GUID format. To convert a GUID to that format, all blocks of the GUID need to be reversed. 
# In addition, the second and third block need to be exchanged.

$sampleGUID = [System.GUID]::NewGuid().Guid

$code = {

    $text = $_.ToCharArray()
    [Array]::Reverse($text)
    -join $text
}

$blocks = $sampleGUID.Split("-") | ForEach-Object -Process $code
$blocks[1], $blocks[2] = $blocks[2], $blocks[1]
$newGUID = $blocks -join "-"

$sampleGUID                     # Output: 4183a4cd-f781-497b-aa85-0c492a034d2b
$newGUID                        # Output: dc4a3814-b794-187f-58aa-b2d430a294c0

# First, the code creates a sample GUID to play with. It then separates the blocks of the GUID by splitting it at "-". Each block is then reversed.
# Finally, blocks 1 and 2 (index starts at 0, so these are blocks 2 and 3 really) are exchanged. 

###########################################################################################################################################################################################

# Tip 5: Controlling Admin PowerShell from Non-Elevated PowerShell


# You can use Start-Process to launch an elevated PowerShell from within your script to do elevated tasks.
# The problem with launching elevated processes is, though, that the non-elevated caller cannot monitor the elevated process. 
# So there is (typically) no way for your non-elevated PowerShell to find out when the elevated PowerShell has finished.

# Here's a creative approach that allows you to launch an elevated PowerShell and wait for it to complete. It also hides the elevated PowerShell window. 

# As a proof, the elevated PowerShell creates a Registry key in HKLM:

$code = { New-Item -Path HKLM:\SOFTWARE\TestKey -ErrorAction SilentlyContinue; Start-Sleep -Seconds 4 }
# Note that the code in $code contains a Start-Sleep statement. 
# It's delaying the code so you can better watch your non-elevated PowerShell to wait for the elevated task to complete.

# execute PowerShell with admin privileges
$handle = Start-Process -FilePath powershell.exe -Verb RunAs -ArgumentList $code -PassThru -WindowStyle Minimized
$handle.Id

while($handle.HasExited -ne $true)
{
    Start-Sleep -Milliseconds 300
}

"Admin job completed."

# To monitor the elevated process, the non-elevated PowerShell asks Start-Process to return a process object (-PassThru). 
# Since the process object represents an elevated process, most of its properties are invisible to the calling non-elevated process for security reasons. 
# This includes the property HasExited. It returns $null.

# However, once the elevated process is terminated, the protection is taken away, and now HasExited returns $true. 
# That's what the non-elevated script can use to check whether the elevated process still runs or has exited.

###########################################################################################################################################################################################

# Tip 6: Replacing Variable Names in ISE 3.0 Editor


# If you want to replace variables in a PowerShell script, in PowerShell ISE 3.0 you can use the following function:

function Replace-Variable
{
    param([Parameter(Mandatory=$true)]$oldName, [Parameter(Mandatory=$true)]$newName)

    $token = $null
    $text = $psISE.CurrentFile.Editor.Text

    $ast = [System.Management.Automation.Language.Parser]::ParseInput($text, [ref]$token, [ref]$null) 
    
    $token | ForEach-Object{
    
        if($_.Kind -eq "Variable")
        {
            $_
        }
        elseif($_.Kind -eq "StringExpandable")
        {
            $_.NestedTokens
        }

    } | Where-Object { $_.Name -eq $oldName } | Sort-Object { $_.Extent.StartOffset } -Descending | ForEach-Object {
    
        $psISE.CurrentFile.Editor.Select($_.Extent.StartLineNumber, $_.Extent.StartColumnNumber +1, $_.Extent.EndLineNumber, $_.Extent.EndColumnNumber)
        $psise.CurrentFile.Editor.InsertText($NewName)
    }
}

# A few things to note: always submit the pure variable name only, and do not include the "$". 
# This call, for example, would replace all instances of $test with $myVariable:

Replace-Variable -oldName test -newName myVariable

# Replace-Variable takes an existing variable name and a new variable name. 
# It then reads the PowerShell script currently displayed in the ISE and replaces all instances of the variable with the new name.

# This function also uses the new PowerShell 3.0 parser, so it will not run with PowerShell 2.0. The new parser can find nested variables. 
# So even if a variable was included in a double-quoted string, it will still be replaced.

###########################################################################################################################################################################################

# Tip 7: Enable PowerShell Remoting in Two Lines of Code


# One common problem with enabling PowerShell Remoting on your box is public networks. 
# As long as there are active network connection labeled as "public" or "unknown", Enable-PSRemoting will fail. 
# Previously, you would have to manually and temporarily disable all of these networks. 
# No more in PowerShell 3.0! Simply use the new –SkipNetworkProfileCheck parameter: 

Enable-PSRemoting -SkipNetworkProfileCheck -Force

# Note that you need Administrator privileges to enable PowerShell Remoting. 


# Another common problem with PowerShell Remoting is that it is by default limited to Kerberos authentication. 
# You cannot remote within a peer-to-peer network, to your own machine or across domains, and you cannot use IP addresses, either. 

# To change that, you need this additional line: 

Set-Item WSMan:\localhost\Client\TrustedHosts * -Force

# This line is not changing the way how others can connect to your computer. 
# It simply controls the computers you are allowed to connect to without using Kerberos authentication. 

###########################################################################################################################################################################################

# Tip 8: Using RegEx to Filter Files


# Get-ChildItem supports basic wildcards, but it does not support the rich feature set of regular expressions. 
# If you combine Get-ChildItem with Where-Object, you can easily add this functionality. 


# lists all DLL files found in System32 folder that start with "a" and have a name of exactly 6 characters:
$pattern = '^a(.{5})\.dll$'
Get-ChildItem $env:windir\System32\*.dll | Where-Object { $_.Name -match $pattern }


# find all files with a name length between 4 and 6 characters:
$pattern = '^a(.{3,5})\.dll$'
Get-ChildItem $env:windir\System32\*.dll | Where-Object { $_.Name -match $pattern }

# Regular expressions can do a lot more. Either search for one of the zillions of tutorials found for free in the Internet, or as a quick start, enter this: 

help regular          # Note that on PowerShell 3.0, this requires that you downloaded the help files first using Update-Help. 

###########################################################################################################################################################################################

# Tip 9: Finding Processes with Highest VM Consumption


# returns the five processes with the highest consumption of virtual memory: 
Get-Process | Sort-Object VM -Descending | Select-Object Name,VM -First 5

# Output:
#        Name                    VM
#        ----                    --
#        powershell_ise          1302523904
#        lync                    1228419072
#        svchost                  899104768
#        outlook                  819945472
#        RDCMan                   762990592

###########################################################################################################################################################################################

# Tip 10: Using "Using:" On Remote PowerShell Sessions (On Powershell V 2.0)


$class = "Win32_LogicalDisk"
$computerName = "storage1"

Invoke-Command -ScriptBlock { param($class) Get-WmiObject -Class $class} -ComputerName $computerName -ArgumentList $class

# In this example, the local variable was turned into an argument and received on the remote side using a param() statement. 
# In order to carry over local variables to remote sessions, submit the local variables to -ArgumentList and receive them in your remote code through param().

# Note that this approach supports positional parameters only, so you must submit multiple values in the order in which they are received by param().

###########################################################################################################################################################################################

# Tip 11: Test Local User Account Credentials


# Here is a snippet that verifies a local user account. Simply submit a username and a password. You get back either $true or $false:

$username = "Administrator"
$password = "dfu"

$computer = $env:COMPUTERNAME

Add-Type -AssemblyName System.DirectoryServices.AccountManagement

$obj = New-Object System.DirectoryServices.AccountManagement.PrincipalContext("machine", $computer)
$obj.ValidateCredentials($username, $password)

###########################################################################################################################################################################################

# Tip 12: Understanding Profile Scripts


# Whenever you want PowerShell to configure or execute code automatically on launch, the code needs to go into one of four profile scripts. 
# They really work pretty much like autoexec.bat for Windows in old days, and execute whenever PowerShell starts.

$profile                        # Output: C:\Users\sihe\Documents\WindowsPowerShell\Microsoft.PowerShellISE_profile.ps1

# This is a user-specific and host-specific path, so it only works for you, 
# and it only works for the current PowerShell host (in this case my ISE editor). It will not execute in other hosts.



$profile.CurrentUserAllHosts    # Output: C:\Users\sihe\Documents\WindowsPowerShell\profile.ps1

# As you see, there is a host-independent generic profile and a host-specific profile, 
# and while Microsoft ships two hosts (PowerShell and PowerShellISE), there can be more like PowerShell Plus, PowerGUI, or others.



# To turn a profile into a user-independent profile, it must reside in the PowerShell system folder:

$profile.AllUsersCurrentHost    # Output: C:\Windows\System32\WindowsPowerShell\v1.0\Microsoft.PowerShellISE_profile.ps1

###########################################################################################################################################################################################

# Tip 13: Disassembling C# Code


# Adam Driscoll, another PowerShell MVP, has published a function called Get-MemberBody to PoshCode: http://poshcode.org/4127. 
# In conjunction with the free tool "ILSpy", you now can easily disassemble and look at source codes for .NET functions.

###########################################################################################################################################################################################

# Tip 14: Getting Screen Information


# Ever needed to know the current screen resolution or related screen information:
Add-Type -AssemblyName System.Windows.Forms

[System.Windows.Forms.Screen]::AllScreens
[System.Windows.Forms.Screen]::PrimaryScreen

# Note that AllScreens returns a screen object for each active screen, so you can also use this to find out the number of screens in use:
[System.Windows.Forms.Screen]::AllScreens | Measure-Object | Select-Object -ExpandProperty Count

###########################################################################################################################################################################################

# Tip 15: Creating Simple Custom Dialog


# PowerShell can display custom dialogs easily. So if you're not satisfied with the dialog buttons available in a standard MsgBox dialog, simply create your own.

# Here's the raw code for a very simplistic two-button dialog that appears centered on screen above all other windows.

[System.Windows.Forms.Application]::EnableVisualStyles()  # To enable visual styles in the PowerShell console as well, add this line to your code:
# Note:  the ISE editor enables visual styles by default. 

Add-Type -AssemblyName System.Windows.Forms
Add-Type -AssemblyName System.Drawing

$form1 = New-Object System.Windows.Forms.Form
$button1 = New-Object System.Windows.Forms.Button
$button2 = New-Object System.Windows.Forms.Button

$System_Drawing_Size = New-Object System.Drawing.Size
$System_Drawing_Size.Width = 256
$System_Drawing_Size.Height = 44
$form1.ClientSize = $System_Drawing_Size
$form1.FormBorderStyle = 3
$form1.TopMost = $true
$form1.Text = "Your Choice"
$form1.ControlBox = $false
$form1.StartPosition = 1

$System_Drawing_Size = New-Object System.Drawing.Size
$System_Drawing_Size.Width = 75
$System_Drawing_Size.Height = 23
$button2.Size = $System_Drawing_Size
$button2.UseVisualStyleBackColor = $true
$button2.Text = "Don't do it"
$System_Drawing_Point = New-Object System.Drawing.Point
$System_Drawing_Point.X = 174
$System_Drawing_Point.Y = 12
$button2.Location = $System_Drawing_Point
$button2.DialogResult = 2

$System_Drawing_Size = New-Object System.Drawing.Size
$System_Drawing_Size.Width = 75
$System_Drawing_Size.Height = 23
$button1.Size = $System_Drawing_Size
$button1.UseVisualStyleBackColor = $true
$button1.Text = "Do it"

$System_Drawing_Point = New-Object System.Drawing.Point
$System_Drawing_Point.X = 92
$System_Drawing_Point.Y = 12
$button1.Location = $System_Drawing_Point
$button1.DataBindings.DefaultDataSourceUpdateMode = 0
$button1.DialogResult = 1

$form1.Controls.Add($button2)
$form1.Controls.Add($button1)

$form1.ShowDialog()                # The code returns either "OK" or "Cancel", depending on which button the user clicked.

###########################################################################################################################################################################################

# Tip 16: Analyzing Script Blocks


# Script blocks are simply pieces of PowerShell code. You probably use them all the time in scripts and functions. 
# A script block is defined by braces and could be as simple as this:

$a = { Get-ChildItem C:\ }

# Now, the variable $a holds code that can be handed over to function parameters (where appropriate) or be executed when you need it:

$a.Invoke()

# In PowerShell 3.0, you can do a lot more. You can, for example, analyze the script block content. 
# This line will return all the tokens and logical sections identified by the PowerShell parser and abstract syntax tree (AST):

$a.Ast.FindAll({$true},$true)

###########################################################################################################################################################################################

# Tip 17: Creating Script Blocks from Strings


# Sometimes you may want to create a script block dynamically from a string. This could be necessary to include local variable content.

# To turn a string into a script block, you cannot cast the string. Instead, use this approach:

# Method 1: 
$folder = "C:\Windows"
$text = "Get-ChildItem -Path $folder"

$sb = [ScriptBlock]::Create($text)
$sb

$sb.Invoke()



# Method 2:
$folder = "C:\Windows"
$text = "Get-ChildItem -Path $folder"

Invoke-Expression $text

###########################################################################################################################################################################################

# Tip 18: Using ValidatePattern attribute


# PowerShell can validate parameters using regular expressions. This example accepts only computer names that start with "PC" followed by three digits:

function Get-PCInfo
{
    param([ValidatePattern('^PC\d{3}$')][String]$computerName)

    "Examining $computerName"
}

Get-PCInfo -computerName PC123

Get-PCInfo -computerName abc
# Output: 

# Get-PCInfo : Cannot validate argument on parameter 'computerName'. 
# The argument "abc" does not match the "^PC\d{3}$" pattern. Supply an argument that matches "^PC\d{3}$" and try the command again.

# Unfortunately, when a user enters a computer name that does not match the pattern, 
# the error message is very cryptic and basically only states that the entered value does not match the regular expression. 


# A better way as pointed out by Bartek Bielawski on powershellmagazine.com (http://www.powershellmagazine.com/2013/05/08/pstip-validatepattern-friendlier-error-messages/) 
# may be by adding a comment to your regular expression like this:

function Get-PCInfo
{
    param([ValidatePattern('(?# Enter a PC Name starting with PC followed by 3 digits)^PC\d{3}$')][String]$computerName)

    "Examining $computerName"
}

Get-PCInfo -computerName abc

# Output: 

# Get-PCInfo : Cannot validate argument on parameter 'computerName'. 
# The argument "abc" does not match the "(?# Enter a PC Name starting with PC followed by 3 digits)^PC\d{3}$" pattern. Supply an argument that 
# matches "(?# Enter a PC Name starting with PC followed by 3 digits)^PC\d{3}$" and try the command again.


# If you want full control over the error message, then you must post-process the parameter value like this:

function Get-PCInfo
{
    param([String]$computerName)

    if($computerName -notmatch "^PC\d{3}$")
    {
        Throw "Get-PCInfo: ComputerName is invalid. Use this format: PCxxx"
    }

    "Examining $computerName"
}

###########################################################################################################################################################################################

# Tip 19: Finding PowerShell Module Requirements


# PowerShell modules extend functionality by adding more cmdlets and/or providers. Modules support copy-and-paste deployment ("XCopy-deployment", if you like), 
# so theoretically, you can copy any module from one computer to another and use it there (use Import-Module).

# Practically, before you try this, you should ask yourself at least three basic questions: 
# 
#         a) Is it legal?
#         
#         b) Where is the module stored? 
#         
#         c) What are additional requirements the module may need? 

$module = Import-Module BitsTransfer -PassThru

$module.ModuleBase                  # To find out the location of a module,
# Output:
#        C:\Windows\system32\WindowsPowerShell\v1.0\Modules\BitsTransfer

# This will report the module folder. In this example, the module BitsTransfer is used which is part of PowerShell by default. 
# If the module was loaded already, you can use Get-Module instead of Import-Module and omit -PassThru.


$module.RequiredAssemblies          # To find out required .NET assemblies

# It will report back a list of DLLs. If these DLLs reside inside the module folder, all is fine. Else, you have external dependencies to take care of. 
# Note that the assemblies reported here may internally have additional dependencies, so this is just a rough clue of what the module may need.

# There are a lot of additional useful properties in $module you can explore.

###########################################################################################################################################################################################

# Tip 20: Make Parameters Mandatory and Optional at the Same Time


# Let's for example assume you want a function that has two parameters: ComputerName and Credential. 
# Both should be optional, but if the user submits a Credential, then the parameter ComputerName must also be submitted. 
# It needs to be either optional or mandatory, depending on the context used.

function Get-ComputerInfo
{
    [CmdletBinding(DefaultParameterSetName = "Integrated")]
    param
    (
        [Parameter(Mandatory = $false, ParameterSetName = "Integrated")]
        [Parameter(Mandatory = $true,  ParameterSetName = "credential")]
        $ComputerName,

        [Parameter(ParameterSetName = "credential")]
        $Credential
    )

    # code follows here
}

# The trick is to assign multiple "Parameter" statements to one parameter. 
# In the example, the parameter ComputerName can be both mandatory and not mandatory, depending on the ParameterSet it is used in.

# Since the parameter Credential is assigned to the ParameterSet "credential" (pick whatever name you want for ParameterSets), 
# PowerShell now knows that in this context, ComputerName must be mandatory.

# The initial CmdletBinding statement sets the default ParameterSet name, 
# so if the user does not provide any parameter or just the (ambiguous) parameter ComputerName, then the ParameterSet is "integrated".

# So if you call Get-ComputerInfo with the parameter Credential, then PowerShell will automatically ask for ComputerName.

function Get-DiskInfo
{
    [CmdletBinding(DefaultParameterSetName = "Integrated")]
    param
    (
        [Parameter(Mandatory = $false, ParameterSetName = "Integrated")]
        [Parameter(Mandatory = $true,  ParameterSetName = "credential")]
        $ComputerName,

        [Parameter(ParameterSetName = "credential")]
        $Credential
    )

    if($PSBoundParameters.ContainsKey("Credential") -and $Credential -is [String])
    {
        $PSBoundParameters.Credential = Get-Credential -UserName $Credential -Message 'Enter Password'
    }

    Get-WmiObject -Class Win32_LogicalDisk -Filter "DriveType=3" @PSBoundParameters -ErrorAction Stop
}

# Get-DiskInfo first checks whether the user has submitted a Credential, and if it is a string, it asks for the password. 
# Then, the submitted parameters are forwarded to Get-WmiObject using splatting, retrieving information about all fixed disks.

# You can use Get-DiskInfo now against your local machine or against any remote machine, optionally using credentials to authenticate, with a minimum of code.

# Likewise, you can adapt this framework to thousands of other WMI-based queries and create your own set of network-aware tools.

###########################################################################################################################################################################################

# Tip 21: Finding Screen Saver Information

[WMI]"Win32_DeskTop='$env:userdomain\$env:username'"           # to retrieve screen saver information for the currently logged on user

# Output:
#        Name               : domain\username
#        ScreenSaverActive  : True
#        ScreenSaverSecure  : 
#        ScreenSaverTimeout : 900
#        SettingID          : 

###########################################################################################################################################################################################

# Tip 22: Define Variable Checkers


# When you assign a mandatory data type to a variable, 
# then this will improve script robustness: whenever a value is (accidentally) assigned to that variable that does not match the expected type, an error is raised.

# In PowerShell 3.0, this concept can be further refined. All validation attributes that previously only worked for parameters now also work for variables.

[String][ValidateSet("dom1","dom2","dom3")]$domain = "dom1"

# The variable $domain now accepts only strings, and because of the ValidateSet attribute, the list of allowable domain names are "dom1", "dom2" and "dom3". 
# Try and assign a different string to $domain, and you get an error message indicating the problem.

$domain = "silence"                    # Exception here: The variable cannot be validated because the value silence is not a valid value for the domain variable.

help advanced_parameters -ShowWindow   # To get a list of validation attributes you can use, execute the following command:

# This line requires PowerShell 3.0 and assumes that you downloaded the PowerShell help first using Update-Help. In PowerShell 2.0, omit the parameter -ShowWindow.

# ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


# Controlling Numeric Range for Variables

# Here is another example. It assigns the data type "Int32" to a variable, so it only accepts numeric values. 
# In addition, it adds a ValidateRange attribute, forcing the variable to numeric values in the range from 1 to 10:

[Int32][ValidateRange(1,10)]$id = 1

$id = "hello"     # Exception: Cannot convert value "hello" to type "System.Int32". Error: "Input string was not in a correct format."
$id = 11          # Exception: The variable cannot be validated because the value 11 is not a valid value for the id variable.

$id = 2

# ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


# Using Script Validators with Variables

# PowerShell 3.0 now supports the use of validators for variable assignments. 
# This is a great way of ensuring that a variable cannot contain illegal data. One of the most versatile validators is the ValidateScript attribute.

# This example makes sure the variable $future contains a date that is in the future. 
# Whenever a script tries and assigns a date to this variable that is in the past, an error is raised, drawing attention to the problem:

[DateTime][ValidateScript({$_ -ge (Get-Date)})]$future = "2014-11-13"

$future = "2014-11-14"
$future = "2014-11-12"          # Exception: The variable cannot be validated because the value 2014/11/12 00:00:00 is not a valid value for the future variable.

# ValidateScript simply expects a script block. Inside of it, $_ represents the value that is going to be assigned to the variable. If the script block returns $false, 
# the value is not assigned and instead an error is raised.


# You can do much more complex things using this approach. This example only accepts file names that exist in the System32 folder:

[String][ValidateScript({ Test-Path $env:windir\system32\$_ })]$dllFile = "avrt.dll"

$dllFile = "find.exe"
$dllFile = "notexist.dll"       # Exception: The variable cannot be validated because the value notexist.dll is not a valid value for the dllFile variable.

###########################################################################################################################################################################################

# Tip 23: Finding Remote Sessions Connected to Your Machine


Get-WSManInstance -ConnectionURI ("http://{0}:5985/wsman" -f $env:COMPUTERNAME) -ResourceURI shell -Enumerate  # Exception here if not Enable-PSRemoting

# Output:
#        rsp             : http://schemas.microsoft.com/wbem/wsman/1/windows/shell
#        lang            : en-US
#        ShellId         : D2872733-6BF5-4647-B334-6DC2CE308B1F
#        Name            : Session1
#        ResourceUri     : http://schemas.microsoft.com/powershell/Microsoft.PowerShell
#        Owner           : domain\username
#        ClientIP        : 192.168.0.1
#        ProcessId       : 4748
#        IdleTimeOut     : PT7200.000S
#        InputStreams    : stdin pr
#        OutputStreams   : stdout
#        MaxIdleTimeOut  : PT2147483.647S
#        Locale          : en-US
#        DataLocale      : en-US
#        CompressionMode : XpressCompression
#        ProfileLoaded   : Yes
#        Encoding        : UTF8
#        BufferMode      : Block
#        State           : Connected
#        ShellRunTime    : P0DT0H1M53S
#        ShellInactivity : P0DT0H1M35S
#        MemoryUsed      : 76MB
#        ChildProcesses  : 0

# It will return anyone connecting via port 5985 to your machine. 
# However, if you're not running in a domain environment, you first have to enable non-Kerberos connections (remember that without Kerberos, 
# you no longer know for sure that the target computer really is the computer it pretends to be):

Set-Item WSMan:\localhost\Client\TrustedHosts * -Force

Get-WSManInstance -ConnectionURI ("http://{0}:5985/wsman" -f $env:COMPUTERNAME) -ResourceURI shell -Enumerate | Select-Object -Property Owner,ClientIP
# Output:
#        Owner                                                       ClientIP
#        -----                                                       --------
#        domain\username                                             192.168.0.1

###########################################################################################################################################################################################

# Tip 24: Killing Remote PowerShell Sessions


# To kill a remote PowerShell session that runs on your machine, you could kill the wsmprovhost.exe task associated with it, 
# but identifying the correct process and killing it is not a robust and recommended way.

# A better way uses this approach:

$uri = ("http://{0}:5985/wsman" -f $env:COMPUTERNAME)

$connection = Get-WSManInstance -ConnectionURI $uri -ResourceURI shell -Enumerate | Where-Object { $_.Owner -eq "domain\user" }

$connection | ForEach-Object { Remove-WSManInstance -ConnectionURI $uri shell @{ ShellID = $_.ShellID } }

# In this example, all remote sessions initiated by the user SomeDomain\SomeUser and using port 5985 would be terminated. 
# Note that in a non-domain environment, you first have to enable non-Kerberos authentication 
# (remember that without Kerberos, you no longer know for sure that the target computer really is the computer it pretends to be)

# ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


# Killing All Remote PowerShell Sessions

# If you want to simply kill all remote PowerShell sessions running on your machine, 
# you can restart the WinRM service like this (provided you own Administrator privileges):

Restart-Service -Name WinRM

# Note however that this will terminate any remote session that uses WinRM.

###########################################################################################################################################################################################

# Tip 25: Waiting for Service State


# Most high-level cmdlets dealing with services have built-in code to wait for state changes. 
# So when you run Restart-Service to restart a service, the cmdlet will pause the script until the service indeed has restarted, 
# and even display a warning message if this takes some time.

# If you'd like to write your own service management logic, you may be better off using the low-level methods provided by service objects. 
# This way, you can stop a service and do other things while the service is stopping, or deal with dependent services.

# Here's how you would access the Spooler service and use its low-level methods to stop it and then wait 2 seconds maximum for the state change to occur:

$service = Get-Service -Name Spooler
$service.Stop()
$service.WaitForStatus("Stopped","00:00:02")

if($service.Status -ne "Stopped")
{
    Write-Warning "Something is finsy here ..."
}

$service

# In this case, if state change did not occur within the 2 seconds timeout, a warning is output. You could, of course, do smarter things instead. 
# Note that to change service status, you probably need Administrator privileges. 
# Note also that low-level methods like Start() and Stop() raise errors when the service is not in the proper status to start or stop it.

###########################################################################################################################################################################################

# Tip 26: Analyzing PowerShell Errors


# PowerShell logs all errors in $error variable (unless the cmdlet uses -ErrorAction Ignore). 
# $error contains the error records which in turn contain a property named HistoryID that links to the command that produced the error.


$Error | Where-Object { $_.InvocationInfo.HistoryID -gt 0 } | ForEach-Object {

    $command = Get-History $_.InvocationInfo.HistoryID
    $duration = ($command.EndExecutionTime - $command.StartExecutionTime).TotalSeconds
    $errorMessage = $_.Exception.Message

    # Add extra property to the object
    $command | Add-Member -MemberType NoteProperty -Name Error -Value $errorMessage
    $command | Add-Member -MemberType NoteProperty -Name Duration -Value $duration

    $result = $command | Select-Object -Property ID,Duration,Error,CommandLine,StartExecutionTime
    $result 

} | Sort-Object -Property Duration -Descending | Out-GridView


$MaximumHistoryCount       # Output: 4096

# Note that $MaximumHistoryCount controls how many items your history list keeps. You may want to increase the default value to cover a larger time frame.

###########################################################################################################################################################################################

# Tip 27: Exploring PowerShell "Suggestions"


# In the PowerShell console, you may have noticed "suggestions" that appear with common errors. Suggestions are designed to help you better understand the error.

# Suggestions are hard-coded into PowerShell and only appear in the console. They do not appear in the ISE editor.

# To get a list of all suggestions implemented, try this:

$psType = [PSObject].Assembly.GetType("System.Management.Automation.HostUtilities", $true)
$psType.GetField("suggestions", "Static,NonPublic,GetField").GetValue($null) | ForEach-Object { New-Object -TypeName PSObject -Property $_ } | Out-GridView

# As it turns out, there are only three suggestions implemented. To see a suggestion in action, enter this in a PowerShell console window:

cd  'C:\Program Files\Internet Explorer'
iexplore

# Error Message(...)
# Suggestion [3,General]: The command iexplore was not found, but does exist in the current location. 
# Windows PowerShell does not load commands from the current location by default. 
# If you trust this command, instead type ".\iexplore". See "get-help about_Command_Precedence" for more details.

# ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


# Adding Suggestions to PowerShell Console

$psType = [PSObject].Assembly.GetType("System.Management.Automation.HostUtilities", $true)
$suggestions = $psType.GetField("suggestions","Static,NonPubic,GetField").GetValue($null)

$newSuggestion = @{

    Id = 4
    Category = "Network Problem"
    MatchType = "Dynamic"
    
    Rule= {
            ($lastError -and
            ($lastError.FullyQualifiedErrorId -eq 'GetWMICOMException,Microsoft.PowerShell.Commands.GetWmiObjectCommand') -and
            ($lastError.Exception.Message -like '*RPC*'))
          }

    Suggestion = {
    
                    'The remote computer does not answer. It either does not exist, or a firewall may block access. Also make sure you did not mistype the computer name.'
                 }

    Enabled = $true
}

$null = $suggestions.Add($newSuggestion)                  # Adding Suggestions to PowerShell Console

# The particular rule in this example looks like this:

# Rule= {
#         ($lastError -and
#         ($lastError.FullyQualifiedErrorId -eq 'GetWMICOMException,Microsoft.PowerShell.Commands.GetWmiObjectCommand') -and
#         ($lastError.Exception.Message -like '*RPC*'))
#       }

# It basically checks whether there was an error record and whether the error ID was related to Get-WmiObject. 
# With this rule alone, the suggestion would appear with any error produced by Get-WmiObject. 
# To make it more specific, the rule also checks whether the error message contains the word "RPC" which indicates that a remote computer was unavailable.

###########################################################################################################################################################################################

# Tip 28: Hiding Code from ISE Debugger


# Typically, when you set breakpoints in your script and then step through your code using F11 or "Debug/Step Into", the debugger will visit all lines that are executed.

# Sometimes, however, you may not want to step through some functions, or you want to make sure that the code in a script module won't be stepped by the debugger.

# While you can press F10 or use "Debug/Step Over" manually to do so, there is also a secret PowerShell attribute you can use to declare code as "hidden". 
# Functions declared with this attribute still execute as usual. When debugging your code, however, 
# the function will always execute as a whole, and the debugger will not step through the code.

function test
{
    param($a)

    Get-Service
}

"Hello"           # put a breakpoint on "Hello" 
test
"Hurray"



function test
{
    [System.Diagnostics.DebuggerHidden()]
    param($a)

    Get-Service
}

"Hello"           # put a breakpoint on "Hello" 
test
"Hurray"

# When you decorate a function with this attribute, you can still set breakpoints inside of the function, 
# but once the debugger reached these breakpoints, you would not be able to step through the remainder of the function.

# That's why there are two more alternative attributes you can use in place of DebuggerHidden: DebuggerStepThrough and DebuggerNonUserCode. 
# They both work the same. During normal debugging, the function would still not be stepped, 
# but when you explicitly set a breakpoint inside the function, then you could step the remaining function once the breakpoint was hit.

function test
{
    [System.Diagnostics.DebuggerStepThrough()]
    param($a)

    Get-Service
}

function test
{
    [System.Diagnostics.DebuggerNonUserCode()]
    param($a)

    Get-Service
}

###########################################################################################################################################################################################

# Tip 29: Finding Office Installation Path


# Microsoft Office has many different versions and exists as a 32-bit and 64-bit edition. 
# Finding the installation path with PowerShell can still be surprisingly simple once you understand the power of wildcards.

Resolve-Path "C:\Program Files*\Microsoft Office\Office*\EXCEL.EXE" | Select-Object -ExpandProperty Path

# Not suit for Office 15: -->> C:\Program Files\Microsoft Office 15\root\office15\excel.exe

###########################################################################################################################################################################################

# Tip 30: Get Time Zone Info


# There is a little known utility called tzutil.exe which can both set the current time zone and get all available time zones. 
# Today, let's check out how PowerShell can embrace raw output and help you get what you want.

tzutil.exe /?

# Output:

#            Windows Time Zone Utility
#            
#            Usage:
#            TZUTIL </? | /g | /s TimeZoneID[_dstoff] | /l>
#            
#            Parameters:
#                /? Displays usage information.
#            
#                /g Displays the current time zone ID.
#            
#                /s TimeZoneID[_dstoff]
#                   Sets the current time zone using the specified time zone ID.
#                   The _dstoff suffix disables Daylight Saving Time adjustments
#                   for the time zone (where applicable).
#            
#                /l Lists all valid time zone IDs and display names. The output will
#                   be: 
#                       <display name>
#                       <time zone ID>
#            
#            Examples:
#                TZUTIL /g
#                TZUTIL /s "Pacific Standard Time"
#                TZUTIL /s "Pacific Standard Time_dstoff"
#            
#            Remarks:
#                An exit code of 0 indicates the command completed successfully.

tzutil.exe /l    # list all available time zones

# Just remember that PowerShell’s operators work as filters when applied to arrays, 
# and that anything a console-based utility like tzutil.exe returns is an array of string lines.


(tzutil.exe /l) -like "*East*"      # to find the time zone that has 'East' in its name

# Output:
#        (UTC-05:00) Eastern Time (US & Canada) 
#        Eastern Standard Time
#        (UTC-05:00) Indiana (East) 
#        US Eastern Standard Time
#        SA Eastern Standard Time
#        Middle East Standard Time
#        North Asia East Standard Time
#        AUS Eastern Standard Time

# If you need context information (include the line following the match, for example), use Select-String instead:


(tzutil.exe /l) | Select-String Berlin -Context 0,1

# Output:
#        > (UTC+01:00) Amsterdam, Berlin, Bern, Rome, Stockholm, Vienna 
#          W. Europe Standard Time


# Of course, tailoring console applications to your needs is only second choice. Things get much easier if the .NET Framework provides information directly:

[System.TimeZoneInfo]::GetSystemTimeZones() | Where-Object { $_.Id -like "*East*" -or $_.DisplayName -like "*East*" } | Select-Object -ExpandProperty ID
# Output:
#        Eastern Standard Time
#        US Eastern Standard Time
#        SA Eastern Standard Time
#        Middle East Standard Time
#        North Asia East Standard Time
#        AUS Eastern Standard Time

# -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


# Changing Current Time Zone

# Here's a helper function that returns the correct time zone ID when you submit part of its name:

function Get-TimeZone($Name)
{
    [System.TimeZoneInfo]::GetSystemTimeZones() | Where-Object { $_.Id -like "*$Name*" -or $_.DisplayName -like "*$Name*" } | Select-Object -ExpandProperty ID
}

Get-TimeZone -Name Berlin     # W. Europe Standard Time
Get-TimeZone -Name China      # China Standard Time
Get-TimeZone -Name West   
# Output:
#        Dateline Standard Time
#        SA Western Standard Time
#        W. Central Africa Standard Time
#        West Asia Standard Time
#        West Pacific Standard Time


# Once you know the official ID of the time zone, use tzutil.exe to make it your current time zone:

tzutil.exe /s "China Standard Time"

###########################################################################################################################################################################################

# Tip 31: Preventing Flashing Console Window


# When you run a console command inside a non-console PowerShell host (like the ISE editor), there will be a flashing window, 
# indicating that the host is launching a temporary console window to host the console command.

#　That's no bad thing, but if you must prevent this, you can always run the console command in a second process with a hidden window.

Start-Process -FilePath tzutil.exe -ArgumentList '/s "W. Central Africa Standard Time"' -WindowStyle Hidden

# Caution: when you run this line, your current time zone will be set to European Standard Time.

# There is generally almost no need anymore to use the low-level .NET System.Diagnostics.Process class to run hidden processes 
# because Start-Process has all the options and parameters you possibly want.

###########################################################################################################################################################################################

# Tip 32: Removing Certificate Plus Private Key


# Starting with PowerShell 3.0, the certificate provider has become a lot more powerful. 
#　It can now easily delete certificates plus their associated private key (which you should only try if you clearly understand what it means to get rid of a digital certificate).

# This line gets you all personal certificates with 'test' in their subjects:
Get-ChildItem Cert:\CurrentUser\My -CodeSigningCert | Where-Object { $_.Subject -like "CN=*test*" } | Select-Object Subject, HasPrivateKey

# And here's the line that deletes all of these certificates including their private keys:

cd Cert:         # Note that the dynamic parameters like -DeleteKey might not show up right away. You may have to first switch to the cert: drive like this:

Get-ChildItem Cert:\CurrentUser\My -CodeSigningCert | Where-Object { $_.Subject -like "CN=*test*" } | Remove-Item -DeleteKey -WhatIf


###########################################################################################################################################################################################

# Tip 33: Examining Certificates


# pick a certificate from your certificate store
$cert = Get-ChildItem Cert:\CurrentUser\My -CodeSigningCert | Where-Object { $_.Subject -like "CN=*Silence*" }

# Next, you can "unfold" all properties and display them as plain text:

$cert | Select-Object -Property *
# Output:
#        PSPath               : Microsoft.PowerShell.Security\Certificate::CurrentUser\My\0B5832F2132863...
#        PSParentPath         : Microsoft.PowerShell.Security\Certificate::CurrentUser\My
#        PSChildName          : 0B5832F2132863...
#        PSDrive              : Cert
#        PSProvider           : Microsoft.PowerShell.Security\Certificate
#        PSIsContainer        : False
#        EnhancedKeyUsageList : {}
#        DnsNameList          : {}
#        SendAsTrustedIssuer  : False
#        Archived             : False
#        Extensions           : {System.Security.Cryptography.Oid, System.Security.Cryptography.Oid, ...}
#        FriendlyName         : 
#        IssuerName           : System.Security.Cryptography.X509Certificates.X500DistinguishedName
#        NotAfter             : 2016/05/11 08:57:08
#        NotBefore            : 2014/05/12 08:57:08
#        HasPrivateKey        : True
#        PrivateKey           : 
#        PublicKey            : System.Security.Cryptography.X509Certificates.PublicKey
#        RawData              : {48, 130, 5, 211...}
#        SerialNumber         : 1C6CD3D3...
#        SubjectName          : System.Security.Cryptography.X509Certificates.X500DistinguishedName
#        SignatureAlgorithm   : System.Security.Cryptography.Oid
#        Thumbprint           : 0B5832F2132863...
#        Version              : 3
#        Handle               : 92318...
#        Issuer               : CN=Test CA 3, DC=domain, DC=corp, DC=company, DC=com
#        Subject              : CN=Silence

# Or, you can display only selected property groups by using wildcards:

$cert | Select-Object -Property *Key*, "*Not*"

# You can even open the certificate store snap-in like this:

$cert | Invoke-Item

###########################################################################################################################################################################################

# Tip 34: Get All Assigned IP Addresses


# Ever needed a list of all IP addresses currently assigned to a machine

[Net.Dns]::GetHostAddresses("") | Select-Object -ExpandProperty IPAddressToString

# Output:
#        fe10::80cb:40dc:abc:223c%11
#        192.168.0.1

###########################################################################################################################################################################################

# Tip 35: Using Bitwise Shift Operators


# PowerShell 3.0 introduces two new operators to bitwise shift. You can use these, for example, to convert GB to MB or KB to GB:

1GB            # Output: 1073741824
1GB -shr 10    # Output: 1048576
1GB -shr 20    # Output: 1024

# -shr 10 basically does the same as dividing by 1024, whereas -shr 20 divides by 1MB. Likewise, -shl does the opposite.

1kb            # Output: 1024
1kb -shl 10    # Output: 1048576
1kb -shl 20    # Output: 1073741824


# shr - SHift Right - 右移
# shl - SHift Left  - 左移

###########################################################################################################################################################################################

# Tip 36: Finding Unused Drive Letter


# Here's a simple way of finding unassigned drive letters:

Get-ChildItem function:[d-z]: -Name | Where-Object { -not (Test-Path -Path $_) }

# If you just want any unused drive letter, pipe the result to Get-Random.

Get-ChildItem function:[d-z]: -Name | Where-Object { -not (Test-Path -Path $_) } | Get-Random

# This approach uses the fact that PowerShell creates a function for each available drive, 
# so the code tests whether or not there is a function names like a drive letter. If there is, then the drive is taken.

###########################################################################################################################################################################################

# Tip 37: Creating Colorized Excel Output


# PowerShell can send data to Excel using CSV files easily. 
# Here's a short script creating a list of running services and opening it in Excel (provided you have Excel installed of course):

$path = "$env:temp\tempfile.csv"
Get-Service | Export-Csv -Path $path -NoTypeInformation -Encoding UTF8 -UseCulture
Invoke-Item -Path $path

# This is fast and reliable, but due to the CSV format, only data can be imported, and you have no way of formatting and colorizing the data.

# Fortunately, modern Excel versions can also import HTML files, as Josh Miller discovered on powershellmagazine.com 
# (http://www.powershellmagazine.com/2013/06/17/pstip-use-excel-to-view-html-output/). 
# To do that, you have to call Excel directly and submit the path to the HTML file as an argument. 

$path = "$env:temp\tempfile.html"

$html = Get-Process | Select-Object CPU,ID,ProcessName | ConvertTo-Html

# Reference for color names http://www.w3schools.com/cssref/css_colornames.asp
$html = $html -replace '^[<]tr[>][<]td[>][<][/]td[>]','<tr style="color:red" ><td></td>'

# Highlight anything that has Chrome or Google In the Name
$html = $html -replace '[<]td(?<T>[>]((chrome)|(Google[^<]*))[<][/]td[>])','<td style="background:blue;color:Yellow" ${T}'
$html | Set-Content -Path $path -Encoding UTF8

# Find a good version of Excel.exe
# $excel = @(Resolve-Path "C:\Program Files*\Microsoft Office\Office*\EXCEL.EXE")[0].Path         # Only suit for version before Office 15
$excel = "C:\Program Files\Microsoft Office 15\root\office15\excel.exe"                           # Office 15 has different path now  

& $excel $path             # Open html with excel  


# -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


# Creating Colorized Excel Output (Part 2)


# Instead of having PowerShell create HTML (via ConvertTo-Html), you can create the HTML output yourself. This way, it is much easier to add the formatting tags you want.

# This example creates an Excel sheet with all services, highlighting running services in green, and displaying stopped services in red:

# write HTML intro code:
$begin = 
{
    '<table>'
    '<tr>'
    '<th>DisplayName</th><th>Status</th><th>Required</th><th>Dependent</th>'
    '</tr>'
}

# this is executed for each data object:
$process = 
{
    if ($_.Status -eq 'Running')
    {
        $style = '<td style="color:green">'
    }
    else
    {
        $style = '<td style="color:red">'
    }
    
    '<tr>'
    '{0}{1}</td><td>{2}</td><td>{3}</td><td>{4}</td>' -f $style, $_.DisplayName, $_.Status, ($_.RequiredServices -join ','), ($_.DependentServices -join ',')
    '</tr>'
}

# finish HTML fragment:
$end = 
{
    '</table>'
}

$path = "$env:temp\tempfile.html"

Get-Service | ForEach-Object -Begin $begin -Process $process -End $end | Set-Content -Path $path -Encoding UTF8

& $excel $path  

# The result is a beautifully colorized Excel worksheet, and by looking at the code, 
# you'll see that creating your HTML data manually provides a lot of additional opportunities to add HTML formatting
# such as cell alignment or font selection, before the HTML is created and fed into Excel.  

###########################################################################################################################################################################################

# Tip 38: Creating Readable CSV-and HTML-Output


# When you convert PowerShell results to CSV or HTML output, you may have discovered that some properties don't display correctly. 
# PowerShell cannot correctly convert arrays to strings and instead displays the array data type. 

$path = "$env:temp\tempfile.hta"

Get-Service | Select-Object -Property DisplayName, Status, DependentServices | ConvertTo-Html | Set-Content -Path $path
Invoke-Item -Path $path

# The results like below:

#   DisplayName                               Status     DependentServices 
#   
#   Adobe Acrobat Update Service              Running    System.ServiceProcess.ServiceController[] 
#   Adobe Flash Player Update Service         Stopped    System.ServiceProcess.ServiceController[] 
#   Application Experience                    Running    System.ServiceProcess.ServiceController[] 

# Since the property "DependentServices" is an array, it is not converted to a string but instead PowerShell displays the underlying data type.

# Method 1: The solution is to add a ForEach-Object loop and preprocess any array property - use the operator -join to convert it manually into a string:

Get-Service | Select-Object -Property DisplayName,Status,DependentServices | ForEach-Object {

    $_.DependentServices = $_.DependentServices -join ", "
    $_

} | ConvertTo-Html | Set-Content -Path $path


# Method 2: 
Get-Service | Select-Object -Property DisplayName,Status,@{Name = "DependentServices"; Expression = {$_.DependentServices} } | ConvertTo-Html | Set-Content -Path $path


Invoke-Item -Path $path

###########################################################################################################################################################################################

# Tip 39: Determining Registry Value Data Type


$regKey = Get-Item 'HKLM:\Software\Microsoft\Windows NT\CurrentVersion'

$regKey.GetValueKind("RegisteredOwner")      # Output: String
$regKey.GetValueKind("DigitalProductId")     # Output: Binary

$regKey.GetValue("RegisteredOwner")          # Output: Silence

$regKey.GetValueNames()

# Output:
#         CurrentVersion
#         CurrentBuild
#         SoftwareType
#         CurrentType
#         InstallDate
#         RegisteredOrganization
#         RegisteredOwner
#         SystemRoot
#         InstallationType
#         EditionID
#         ProductName
#         ProductId
#         DigitalProductId
#         DigitalProductId4
#         CurrentBuildNumber
#         BuildLab
#         BuildLabEx
#         BuildGUID
#         CSDBuildNumber
#         PathName
#         CSDVersion

###########################################################################################################################################################################################

# Tip 40: Negating Variables


# Let's assume you have a variable with a negative value, and you'd like to make it a positive value.
$a = -10
$a
- $a

# Basically, this approach negates the variable, so you can do the opposite as well:
$a = 10
- $a

# Note that this will not change $a unless you reassign the result to the variable.

# If you just want to make sure a variable has a positive number, try Abs():
$a = -10
[Math]::Abs($a)

# To make sure your variable is always negative, you can combine both:
$a = 10
$a = - [Math]::Abs($a)

###########################################################################################################################################################################################

# Tip 41: Importing Website Tables into Excel


# Sometimes, you might see interesting information on websites. For example, navigating to http://www.ssa.gov/OACT/babynames/index.html will open a site with popular baby names. 
# If you'd like to work with that data, the traditional approach is to read the raw HTML from the website and parse it using regular expressions.

# A completely different approach uses Invoke-WebRequest (new in PowerShell 3.0) to grab the HTML table, write it to disk and feed it to Microsoft Excel. 
# The result is an Excel table that holds the data published by the website.

# Here's a piece of sample code that illustrates how PowerShell can grab the baby names and feed them to Excel:

$url = "http://www.ssa.gov/OACT/babynames/index.html"
$outfile = "$env:temp\tempfile.html"

$data = Invoke-WebRequest -Uri $url

@($data.ParsedHtml.getElementsByTagName("Table"))[0].OuterHTML | Set-Content -Path $outfile

$excel = "C:\Program Files\Microsoft Office 15\root\office15\excel.exe" 

& $excel $outfile

# You can easily adapt this code to other websites. For example, by changing the $URL variable to http://www.x-rates.com/, 
# you'll get current exchange rates instead of baby names. Maybe you want to do the same with your company restaurant website and their weekly menu.

###########################################################################################################################################################################################

# Tip 42: Writing DWORD-Values to Registry


# In PowerShell 2.0, Set-ItemProperty by default always creates REG_SZ (String) values. 
# PowerShell 3.0 is smarter. When you submit a numeric value, then PowerShell 3.0 automatically creates a DWORD value. If you submit a non-numeric value, a REG_SZ is created.

# Try for yourself! This line will create a REG_SZ value in PowerShell 2.0 and a REG_DWORD value in PowerShell 3.0:

Set-ItemProperty -Path HKCU:\Software -Name testvalue -Value 12

# This can lead to unexpected results. That's why you should make sure to specify the data type you want. This line creates DWORD values both in PowerShell 2.0 and 3.0:

Set-ItemProperty -Path HKCU:\Software -Name testvalue -Value 12 -Type DWord

###########################################################################################################################################################################################

# Tip 43: Manipulating File System Paths


$path = "C:\Users\Silence\Desktop\Function.ps1"
$array = $path -split "\\"


# One:
$newPath = $array[0,3,4]
$newPath -join "\"                                 # Output: C:\Desktop\Function.ps1


# Two:
$array[2] = "OtherUser"
$array -join "\"                                   # Output: C:\Users\OtherUser\Desktop\Function.ps1


# Three:
$length = $array.Count
$newPath = $array[,0+3..$length]                  # Note how the array elements for the new path are picked:
$newPath -join "\"


$newPath = $array[,0+3..$length] 
# This line takes the first path element (index 0) and the elements 4 and all following elements (index 3 and more).

# The secret here is that PowerShell allows you to submit arrays of indices.
# The expression x..y creates a numeric array of the range x to y where x and/or y can be also variables.

# When you want to add individual indices, you have to turn them also into arrays because only arrays can be added to arrays. 
# That's why the index 0 is written like this: ,0. This creates an array that only holds the zero, 
# and this array can then be added to the numeric range array, resulting in one single array with all the indices you want.

$array = ,0
$array

$array + 1..3
# Output:
#         0
#         1
#         2
#         3

# ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

# This can become even more convenient when you cast the array to an ArrayList type. Now, it is very easy to exclude existing or add new path elements.

# This example renames the first subfolder, excludes the second subfolder and adds new subfolder after the forth existing subfolder:

$path = "C:\Users\Silence\Desktop\Function.ps1"

[System.Collections.ArrayList]$array = $path -split "\\"
$array[1] = "MyUsers"
$array.RemoveAt(2)
$array.Insert(3, "NewSubFolder")
$array.Insert(4, "AnotherNewFolder")

$array -join "\"                       # Output: C:\MyUsers\Desktop\NewSubFolder\AnotherNewFolder\Function.ps1

###########################################################################################################################################################################################

# Tip 44: Returning Multiple Values


# A PowerShell function can return multiple values. To receive them, simply assign the result to multiple variables:

function Get-DateTimeInfo
{
    # Value1 
    Get-Date -Format "dddd"

    # Value2
    Get-Date -Format "MMMM"

    # Value3
    Get-Date -Format "HH:mm:ss"
}

$day, $month, $time = Get-DateTimeInfo

"Today is $day, the month is $month, and it is $time"

# Output:
#        Today is Friday, the month is November, and it is 09:36:58

###########################################################################################################################################################################################

# Tip 45: Finding Type Accelerators


# PowerShell maintains a list of shortcuts for .NET types to make coding more convenient for you. 

# For example, to convert a string to a DateTime type, you can write:

[DateTime]"2014-11-17"      # Output: Monday, November 17, 2014 00:00:00

# Behind the scenes, this is just a shortcut for the real type name "System.DateTime". You can always find out the real type by using the FullName property:

[DateTime].FullName         # Output: System.DateTime

# To get a list of all supported "type accelerators" (shortcuts), you can use the following piece of code. 
# It returns all type accelerators implemented in PowerShell. 
# This is extremely useful because it points you to all the internal .NET types the PowerShell developers thought were important:

[PSObject].Assembly.GetType("System.Management.Automation.TypeAccelerators")::Get | Sort-Object -Property Value

[PSObject].Assembly.GetType("System.Management.Automation.TypeAccelerators")::Get | Sort-Object -Property Value | Out-GridView

###########################################################################################################################################################################################

# Tip 46: Adding New Type Accelerators in Powershell


# If you find yourself using certain .NET types frequently, you may want to make your life easier and implement shortcuts.

# For example, there is a .NET type called "System.IO.Path" with a lot of useful path functionalities:

[System.IO.Path]::GetExtension("C:\test.txt")
[System.IO.Path]::ChangeExtension("C:\test.txt","bak")

# If you feel tired typing the long .NET type name all the time, simply add a shortcut like so:

[PSObject].Assembly.GetType("System.Management.Automation.TypeAccelerators")::Add("Path", [System.IO.Path])

# Now, you can access the very same functionality via your new shortcut "Path":

[Path]::GetExtension("C:\test.txt")
[Path]::ChangeExtension("C:\test.txt", "bak")

# To get a list of all methods and properties supported by a type, try this:

[Path] | Get-Member -Static

###########################################################################################################################################################################################

# Tip 47: Go to Function Definition on F12


# If you are into writing long and complex PowerShell code with a lot of functions, then this one is for you. 
# In other development environments, when you place the cursor on a function and press F12, the editor takes you to the function definition. PowerShell ISE won't do that.

# You can add functionality to ISE, though. The following code adds a new command "Find Definition" to the AddOns menu and assigns a F12 keyboard shortcut to it.

# Next time you click on a function inside a lengthy script, ISE takes you directly to the function definition--provided it can be found somewhere inside of that script.

function Find-Definition
{
    $e = $psISE.CurrentFile.Editor
    $column = $e.CaretColumn
    $line = $e.CaretLine

    $AST = [Management.Automation.Language.Parser]::ParseInput($e.Text,[ref]$null,[ref]$null)

    $AST.Find({param($ast)

            ($ast -is [System.Management.Automation.Language.CommandAst]) -and
            (($ast.Extent.StartLineNumber -lt $Line -and $ast.Extent.EndLineNumber -gt $line) -or
            ($ast.Extent.StartLineNumber -eq $Line -and $ast.Extent.StartColumnNumber -le $Column) -or
            ($ast.Extent.EndLineNumber -eq $Line -and $ast.Extent.EndColumnNumber -ge $Column))}, $true) | 
            
            Select-Object -ExpandProperty CommandElements | ForEach-Object { 
             
                $name = $_.Value
                  
                $AST.Find({param($ast)

                        ($ast -is [System.Management.Automation.Language.FunctionDefinitionAst]) -and
                        ($ast.Name -eq $name)}, $true) | Select-Object -Last 1 | ForEach-Object {

                            $e.SetCaretPosition($_.Extent.StartLineNumber,$_.Extent.StartColumnNumber)
                        }
            }
}

$psISE.CurrentPowerShellTab.AddOnsMenu.Submenus.Add("Goto Definition", {Find-Definition}, "F12")

###########################################################################################################################################################################################

# Tip 48: Vertical Grid View


# You can always pipe objects to Out-GridView and get a nice extra window with all of the object properties lined up as table. 
# That's useful if you want to display a lot of objects.

# If you just want to display one object with all of its properties, a vertical grid view would be a lot nicer. 
# Actually, you can create your own by utilizing a so-called property grid. 

function Show-Object
{
    param
    (
        [Parameter(Mandatory=$true,ValueFromPipeline=$true)]
        [Object]
        $InputObject,

        $Title
    )

    if(!$Title) { $Title = "$InputObject" }

    $form = New-Object System.Windows.Forms.Form
    $form.Size = New-Object System.Drawing.Size @(600,600)
    $propertyGrid = New-Object System.Windows.Forms.PropertyGrid
    $propertyGrid.Dock = [System.Windows.Forms.DockStyle]::Fill
    $form.Text = $Title
    $propertyGrid.SelectedObject = $InputObject
    $propertyGrid.PropertySort = "Alphabetical"
    $form.Controls.Add($propertyGrid)
    $form.TopMost = $true

    $null = $form.ShowDialog()
}

# Now, you can pipe any object into Show-Object, and it will display a vertical property grid. 
# Even more interesting, all writeable properties are bolded, and you could actually change those right in the grid (watch out, changing things can be dangerous). 
# And: when you select a property, many objects will show a detailed description in the window status bar:

Get-Process -Id $pid | Show-Object

$Host | Show-Object

Get-Item -Path $pshome\powershell.exe | Show-Object

###########################################################################################################################################################################################

# Tip 49: Three Most Useful ISE Tricks


<#

If you use PowerShell 3.0 and the ISE editor, then here are the three most useful tricks you should know:

1. Press CTRL+J to open a list of predefined code snippets for loops, conditions, functions, and workflows. This will get you started in no time!

2. When you select code, pressing F8 will execute the selected code only. 
   This works even inside commented areas, so you could use < # and # > to place some sample code into your script, then to execute, select the code and press F8.

3. To get extensive help for cmdlets, click on a cmdlet in your script and press F1.

#>

###########################################################################################################################################################################################

# Tip 50: Turn Out-GridView into Selection Dialog


# Finally, in PowerShell 3.0, Out-GridView can turn into a versatile selection dialog - just add the new parameter -PassThru and watch:

$title = "select one or more files to open"

Get-ChildItem -Path $env:windir -Filter *.log | Out-GridView -PassThru -Title $title | ForEach-Object { notepad $_.FullName }

# You can basically pipe anything into Out-GridView. The user then can select part of the output, 
# or filter the results with a keyword, then select one, some or all of the results. 
# By clicking OK, the selected objects are then passed on to the next command.

# Note: using "start" instead of "notepad" will open the selected files with the default application for the filetype (if you had removed the restriction to *.log for example).

###########################################################################################################################################################################################

# Tip 51: Copying Results to Clipboard


# To easily copy cmdlet results to other applications, simply pipe them to clip.exe. Next, paste the results into whatever application you want:

# Method One:
Get-Service | clip


# Method Two:
[System.Windows.Forms.Clipboard]::SetText((Get-Service | Out-String))
[System.Windows.Forms.Clipboard]::GetText()

# http://powershell.com/cs/blogs/tips/archive/2013/09/18/copying-results-to-clipboard.aspx

###########################################################################################################################################################################################

# Tip 52: Verbose Output for PowerShell Functions


# To add on-demand verbose output to your PowerShell functions, make sure your functions support the common parameters by adding the CmdletBinding attribute. 

function test
{
    [CmdletBinding()]
    param()

    Write-Verbose "Starting..."
    "Do something"
    Write-Verbose "Shutting Down."
}

test                                    # when you run it like this, you get only your regular output          
# Output: Do something

test -Verbose                           # if you add -Verbose, you also see your verbose messages
# Output:
#        VERBOSE: Starting...
#        Do something
#        VERBOSE: Shutting Down.

###########################################################################################################################################################################################

# Tip 53: Showing Hidden Files in File Explorer


# PowerShell can easily read and write to the Registry, the central store for Windows settings. 

# Here's a function that can turn the display of hidden files in File Explorer on and off. 
# The clever part is not necessarily writing new values to the Registry. 
# It is rather how the script manages to make sure that File Explorer windows recognize the changes and update their content: 

function Show-HiddenFile
{
    param([Switch]$Off)

    $value = -not $off.IsPresent
    Set-ItemProperty -Path HKCU:\Software\Microsoft\Windows\CurrentVersion\Explorer\Advanced -Name Hidden -Value $value -Type DWord

    $shell = New-Object -ComObject Shell.Application
    $shell.Windows() | Where-Object { $_.Document.URL -eq $null } | ForEach-Object { $_.Refresh() }
}

Show-HiddenFile -Off

###########################################################################################################################################################################################

# Tip 54: Creating Hard Links


# Hard links are file "phantoms" in the NTFS file system. They make one file visible in multiple file system locations (within one volume). 

# So the file occupies space only where it originally was stored but is also available elsewhere. 
# This can be useful if you must make available large files in multiple file locations.

# Here's the function New-HardLink. It illustrates how PowerShell can access low-level API functions:

function New-HardLink
{
    param
    (
        [Parameter(Mandatory=$true)]
        $OriginalFilePath,

        [Parameter(Mandatory=$true)]
        $MirroredFilePath
    )

    $signatrure = '
    
        [DllImport("Kernel32.dll")]
        public static extern bool CreateHardLink(string lpFileName,string lpExistingFileName,IntPtr lpSecurityAttributes);

    '
    Add-Type -MemberDefinition $signatrure -Name Creator -Namespace Link

    [Link.Creator]::CreateHardLink($MirroredFilePath, $OriginalFilePath, [IntPtr]::Zero)
}

# And here is what you can do with it:

$Original = "$env:temp\testfile.txt"
$copy1 = "$env:userprofile\desktop\mirrorfile1.txt"
$copy2 = "$env:userprofile\desktop\mirrorfile2.txt"

Set-Content -Path $Original -Value "Hello"

New-HardLink -OriginalFilePath $Original -MirroredFilePath $copy1
New-HardLink -OriginalFilePath $Original -MirroredFilePath $copy2

# The code first creates a physical file in the temp folder. Then, it creates two hard links on your desktop. 
# They appear as mirrorfile1.txt and mirrorfile2.txt, and although they look like separate files, in reality they both point to the temporary file.

# You can now open one of the two files on your desktop, make some changes, then save and close. 
# Once you open the other file, the very same updated content appears. You can also simply delete a phantom file to get rid of the hard link.

###########################################################################################################################################################################################

# Tip 55: Testing Administrator Privileges


# To test whether a script is run by an Administrator with full privileges (UAC elevated), here is an unusual approach that illustrates the enormous flexibility in PowerShell:

function Test-Admin 
{
    [bool]((whoami /groups) -match "S-1-16-12288")
}

# It basically tests whether the current user is member of the high integrity group (S-1-16-12288) which is only the case for elevated admins. 


Test-Admin             # Output: false



function Test-Admin2
{
    $id = New-Object Security.Principal.WindowsPrincipal $([Security.Principal.WindowsIdentity]::GetCurrent())
    $id.IsInRole([Security.Principal.WindowsBuiltinRole]::Administrator)
}

Test-Admin2            # Output: false

###########################################################################################################################################################################################

# Tip 56: Creating Symbolic Links


# Symbolic links work very similar to "regular" link files (*.lnk): they can point to virtually any file or folder and even UNC paths. 
# Unlike lnk-files, to create symbolic links you need full Administrator privileges, and users cannot access the symlink properties.

function New-SymbolicLink
{
    param
    (
        [Parameter(Mandatory=$true)]
        $OriginalPath,

        [Parameter(Mandatory=$true)]
        $MirroredPath,

        [ValidateSet("File", "Directory")]
        $Type = "File"
    )

    if(!([bool]((whoami /groups) -match "S-1-16-12288")))
    {
        Write-Warning "Must be an Admin"
        break
    }

    $signature = '
    
        [DllImport("kernel32.dll")]
        public static extern bool CreateSymbolicLink(string lpSymlinkFileName, string lpTargetFileName, int dwFlags);
    '

    Add-Type -MemberDefinition $signature -Name Creator -Namespace SymbolicLink

    $flags = [Int]($Type -eq "Directory")

    [SymbolicLink.Creator]::CreateSymbolicLink($MirroredPath, $OriginalPath, $flags)
}

$downloads = "$env:userprofile\Downloads"
$desktop = "$env:userprofile\Desktop\MyDownloads"

New-SymbolicLink -OriginalPath $downloads -MirroredPath $desktop -Type Directory

# When you run the code (with full Administrator privileges), it makes your downloads folder available right on your desktop. 
# Right-click the symbolic link and choose Properties to compare this to "regular" *.lnk link files.


# Cmd command: mklink 

###########################################################################################################################################################################################

# Tip 57: Check Monitor Brightness


# If you want to check your current display brightness (preferably on notebooks, of course), here's a quick function:

function Get-MonitorBrightness
{
    param($ComputerName, $Credential)

    Get-WmiObject -Namespace root/WMI -Class WmiMonitorBrightness @PSBoundParameters | Select-Object -Property PSComputerName, CurrentBrightness, Levels
}

Get-MonitorBrightness

# It even supports -ComputerName and -Credential, so you can query remote systems as well. 

# And if you submit a comma-separated list of computer names or IP addresses to -ComputerName, 
# you get the results for all of those--provided you have local Admin privileges on these systems.


# -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------



# Setting Monitor Brightness

# If your display driver supports WMI, then you can change the display brightness using PowerShell - event on remote machines!

function Set-MonitorBrightness
{
    param
    (
        [Parameter(Mandatory=$true)]
        [Int][ValidateRange(0,100)]
        $Value,

        $Computer,
        $Credential
    )

    $null = $PSBoundParameters.Remove("Value")

    $helper = Get-WmiObject -Namespace root/WMI -Class WmiMonitorBrightnessMethods @PSBoundParameters 
    $helper.WmiSetBrightness(1, $Value)
}

# Simply specify a value in the range of 0 to 100 and see your display brightness change. 
# Supply remote computer machine name(s) or IP address(es) to the -ComputerName parameter, 
# and surprise your colleagues with a remotely dimmed display or dim all displays during lunch break 
# (as usual, WMI remote access requires local Administrator privileges and that you have set up a remote administration firewall rule).

# If you get a "not supported" error message, then your display driver unfortunately came without WMI support.

# This could be the "fun" part: simulating a flaky display:

for($x = 0; $x -lt 20; $x++)
{
    Set-MonitorBrightness -Value (Get-Random -Minimum 20 -Maximum 101)
    Start-Sleep -Seconds 1
}

###########################################################################################################################################################################################

# Tip 58: Converting Excel CSV to UTF8


# When you export Microsoft Excel spreadsheets to CSV files, Excel by default saves CSV files in ANSI encoding. 
# That's bad because special characters will break once you import the data into PowerShell using Import-Csv.

# To make sure special characters won't get lost, you can make sure the CSV file uses UTF8 encoding before you import the data:

$path = "C:\temp\somedata.csv"
(Get-Content -Path $path) | Set-Content -Path $path -Encoding

###########################################################################################################################################################################################

# Tip 59: Finding Scripts by Keyword


# With an increasing number of PowerShell scripts on your hard drive, it can become hard to find the script you are looking for. 
# Here's a helper function called Find-Script. Simply submit a keyword, and PowerShell will locate any script within your user profile that has your keyword anywhere inside it.
# The result displays in a grid view window, and you can then optionally click and select the file(s) you want to open in the ISE editor. 

function Find-Script
{
    param
    (
        [Parameter(Mandatory=$true)]
        $KeyWord,

        $Maximum = 20,
        $StartPath = $env:userprofile
    )

    Get-ChildItem -Path $StartPath -Filter *.ps1 -Recurse -ErrorAction SilentlyContinue | 
        
        Select-String -SimpleMatch -Pattern $KeyWord -List | Select-Object -Property FileName, Path, Line -First $Maximum | 

        Out-GridView -Title "Select Script File" -PassThru | ForEach-Object { ise $_.Path }
}

Find-Script -KeyWord "Tip" -Maximum 3 -StartPath "C:\Users\v-sihe\Desktop\Tools\PowershellScripts"

# By default, Find-Script returns only the first 20 scripts that meet your request. 
# With the parameters -Maximum and -StartPath, you can change both the maximum count and the search location.

###########################################################################################################################################################################################

# Tip 60: Creating Objects with CSV


# There are many ways to create custom objects. Here's a creative solution that can be useful in many scenarios: 
# create a text-based comma-separated list of values, and use ConvertFrom-Csv to produce objects:

for($x = 0; $x -lt 20; $x++)
{
    ($x, (Get-Random), (Get-Date) -join ",") | ConvertFrom-Csv -Header ID, RandomNumber, Date
}

# Unfortunately, this approach isn't very fast. So here are three other techniques to create objects with content. 
# Measure-Command measures the time it takes to create 2000 objects:


Measure-Command {

    for($x=0; $x -lt 2000; $x++)
    {
        ($x,(Get-Random),(Get-Date) -join ',') | ConvertFrom-Csv -Header ID, RandomNumber, Date
    }
}
# TotalSeconds      : 0.5908321


Measure-Command {

    for($x=0; $x -lt 2000; $x++)
    {
        $obj = 1 | Select-Object -Property ID, RandomNumber, Date
        $obj.ID = $x
        $obj.RandomNumber = Get-Random
        $obj.Date = Get-Date
        $obj
    }
}
# TotalSeconds      : 0.7420918


Measure-Command {

    for($x=0; $x -lt 2000; $x++)
    {
        [PSObject]@{
            ID = $x
            RandomNumber = Get-Random
            Date = Get-Date
        }
    }
}
# TotalSeconds      : 0.3405828


Measure-Command {

    for($x=0; $x -lt 2000; $x++)
    {
        [Ordered]@{
            ID = $x
            RandomNumber = Get-Random
            Date = Get-Date
        }
    }
}
# TotalSeconds      : 0.2712797


# As it turns out, the last two approaches are about 3 times faster than the CSV approach, 
# yet all of these take significantly less than 1 second on our test system, so the real world differences are not of practical significance. 

# Pick the one you personally like best - but note that the last example needs PowerShell 3.0 or better.


# Note:
#      A pipeline is always slower, so that's why the foreach-object pipeline solution was slower by nature.
#      
#      [PSObject] is a cast: A hashtable is casted (converted) to a PSObject object (a powershell object).

###########################################################################################################################################################################################

# Tip 61: Finding All PowerShell Profile Scripts


# Sometimes it can get confusing which startup scripts run when PowerShell starts. 
# There can be plenty, and they may be different, depending on whether you use the PowerShell console, the ISE, or yet another host.

# Knowing about your profile scripts can be extremely important, though. They essentially determine the customizations applied to PowerShell. 

# The function Get-PSProfileStatus lists all potential startup scripts for the host (PowerShell environment) you run it in. 
# It also reports which profile scripts are really present:

function Get-PSProfileStatus
{
    $profile | Get-Member -MemberType NoteProperty | Select-Object -ExpandProperty Name | ForEach-Object {
    
        $_, (Split-Path $profile.$_ -Leaf), (Split-Path $profile.$_), (Test-Path -Path $profile.$_) -join "," | 

        ConvertFrom-Csv -Header Profile, FileName, FolderName, Present
    }
}

Get-PSProfileStatus

# Output:

#        Profile                         FileName                                    FolderName                                      Present                                             
#        -------                         --------                                    ----------                                      -------                                             
#        AllUsersAllHosts                profile.ps1                                 C:\Windows\System32\WindowsPowerShell\v1.0      False                                               
#        AllUsersCurrentHost             Microsoft.PowerShellISE_profile.ps1         C:\Windows\System32\WindowsPowerShell\v1.0      False                                               
#        CurrentUserAllHosts             profile.ps1                                 C:\Users\sihe\Documents\WindowsPowerShell       False                                               
#        CurrentUserCurrentHost          Microsoft.PowerShellISE_profile.ps1         C:\Users\sihe\Documents\WindowsPowerShell       False  

###########################################################################################################################################################################################

# Tip 62: Checking Disk Partitions and Block Size


Get-WmiObject -Class Win32_Diskpartition | Select-Object -Property __Server, Caption, BlockSize

#　　Output:
#         __SERVER             Caption                              BlockSize
#         --------             -------                              ---------
#         SIHE-01              Disk #0, Partition #0                      512
#         SIHE-01              Disk #0, Partition #1                      512
#         SIHE-01              Disk #0, Partition #2                      512

# Use Get-WmiObject's parameter -ComputerName to do the same remotely, against one or more computers.

# To see all the other WMI classes you can use in place of Win32_DiskPartition, try this:

Get-WmiObject -Class Win32_* -List | Where-Object { ($_.Qualifiers | Select-Object -ExpandProperty Name) -notcontains 'Association' } | Where-Object { $_.Name -notlike "*_Perf*" } 

###########################################################################################################################################################################################

# Tip 63: Encoding a Love Letters (and Other Things) in Hex Strings


# If your partner is as geeky as you, he or she may enjoy a private message in hex encoding. Everyone else may at least enjoy the technology used here, concatenating a number of type conversions:

$text = "This is my secret message"
-join ([Byte[]][Char[]]$text | ForEach-Object { '{0:x2}' -f $_ })   

# The text is converted to a character array, this is then converted into a byte array, 
# and the bytes are finally converted to two-digit hex pairs which -join combines to something like this:

# Output: 84104105115321051153210912132115101991141011163210910111511597103101

-join $(foreach($hex in ('54686973206973206d7920736563726574206d657373616765' -split '(?<=\G[0-9a-f]{2})(?=.)')){ [Char][System.Convert]::ToByte($hex, 16) })

# Output: This is my secret message

###########################################################################################################################################################################################

# Tip 64: Password Obfuscator Script


# Ever had the need to store a password in a script? Ever needed to automate a credential dialog? 
# First: storing passwords and other confidential information in scripts is bad. 
# Second: if you must do it, make it at least harder for people to steal information.

# Here is a script generator. Run it, and enter a doman/username plus a password. The generator script will then create a new script for you. 

$user = Read-Host "Enter Username"
$pwd = Read-Host "Enter Password"

$key = 1..32 | ForEach-Object { Get-Random -Maximum 256 }
$pwdEncrypted = $pwd | ConvertTo-SecureString -AsPlainText -Force | ConvertFrom-SecureString -Key $key

$text = @()
$text += '$password = "{0}"' -f ($pwdEncrypted -join " ")
$text += '$key = "{0}"' -f ($key -join " ")
$text += '$passwordSecure = ConvertTo-SecureString -String $password -Key ([Byte[]]$key.Split(" "))' 
$text += '$cred = New-Object System.Management.Automation.PSCredential("{0}", $passwordSecure)'
$text += '$cred'

$newFile = $psISE.CurrentPowerShellTab.Files.Add()
$newFile.Editor.Text = $text | Out-String

# Output: ==> new script

#        $password = "76492d1116743f0423413b16050a5345MgB8AHkAYwAyAFYAcgBpADMAdgBtAGsAdQBXAEUAWABFACsAYQBqAEgAYwBBAEEAPQA9AHwAMgBlADEAMAA4ADIANgA3ADEAYQA1ADAAMg
#                    A4AGMANgA5ADAAZQAzADgANABlADcAOAA1ADAAYgBjAGIAMQAwADIAOAA4ADcAZAA5ADEAMgBkADYAOABkAGQANABiADUAMgA4ADgANQBlADIAOQA2AGEAMQAwADMAMwA0AGYAOQA="
#        
#        $key = "139 89 190 73 180 160 138 92 240 38 28 223 42 81 163 217 204 105 161 163 143 78 197 63 10 186 1 187 215 227 227 43"
#        $passwordSecure = ConvertTo-SecureString -String $password -Key ([Byte[]]$key.Split(" "))
#        $cred = New-Object System.Management.Automation.PSCredential("{0}", $passwordSecure)
#        $cred

# When you run it, it returns a Credential object that you can immediately use to authenticate. Simply pass it to any parameter that expects a credential object.

# Again, this is not safe. But you do need a bit more knowledge to get to the embedded password

###########################################################################################################################################################################################

# Tip 65: What Is Going On Here?


# Frequently, you will have PowerShell retrieve data, and then you pick parts of the information and use it in reports. Like here:

$serial = Get-WmiObject -Class Win32_OperatingSystem | Select-Object -Property SerialNumber
"Serial Number is $serial"     # Output: Serial Number is @{SerialNumber=00392-918-5000002-85646}

$serial
# Output:
#        SerialNumber                                                                                                                                                                                                         
#        ------------                                                                                                                                                                                                         
#        00392-918-5000002-85646 

# Problem is the column header. Whenever you use Select-Object to just pick one column, remove the header by using -ExpandProperty rather than -Property:

$serial = Get-WmiObject -Class Win32_OperatingSystem | Select-Object -ExpandProperty SerialNumber
"Serial Number is $serial"     # Output: Serial Number is 00392-918-5000002-85646

###########################################################################################################################################################################################

# Tip 66: Creating Calendars (and Lists of Dates)


$month = 11
$year = 2014
1..[DateTime]::DaysInMonth($year,$month) | ForEach-Object { (Get-Date -Day $_) }



# This can be pretty useful: just add a day filter, and you get working days only. 
# This will list all Mondays through Fridays in the given month (because it excludes weekday 0 (Sunday) and weekday 6 (Saturday):

$month = 11
$year = 2014
1..[DateTime]::DaysInMonth($year,$month) | ForEach-Object { (Get-Date -Day $_) } | Where-Object { 0,6 -notcontains $_.DayOfWeek }



# Likewise, this will count all Wednesdays and Fridays in a given month:

$month = 11
$year = 2014
$days = 1..[DateTime]::DaysInMonth($year,$month) | ForEach-Object { (Get-Date -Day $_) } | Where-Object { 3,5 -contains $_.DayOfWeek }
$days

"There are {0} Wednesdays and Fridays" -f $days.Count      # Output: There are 8 Wednesdays and Fridays

###########################################################################################################################################################################################

# Tip 67: Finding Cmdlets


# Get-Command can be used to find cmdlets, but in PowerShell 3.0 it will often return many more cmdlets than expected. 
# Due to module auto-loading, Get-Command returns not just the cmdlets from currently loaded modules but from all potentially available modules.

# If you just want to find a cmdlet from one of the currently loaded modules, use the new –ListImported parameter:

Get-Command -Verb Get | Measure-Object | Select-Object -ExpandProperty Count                        # Output: 169
Get-Command -Verb Get -ListImported | Measure-Object | Select-Object -ExpandProperty Count          # Output: 50

###########################################################################################################################################################################################

# Tip 68: Finding AD User Accounts


$searcher = [ADSISearcher]'(&(objectClass=User)(objectCategory=person)(SAMAccountName=*))'

$searcher.FindOne()       # finding first match
# Output:
#         Path                                                                                Properties                                                                                                
#         ----                                                                                ----------                                                                                                
#         LDAP://CN=Samir Mowade,OU=UserAccounts,DC=fareast,DC=corp,DC=microsoft,DC=com       {lastlogoff, codepage, department, msrtcsip-primaryhomeserver...}  

$searcher.FindAll()       # finding ALL matches

# This would find all user accounts with a SamAccountName that starts with "tobias". You can now use this approach to easily find out where an account is located:

$searcher.FindAll() | Select-Object -ExpandProperty Path       # find account location

# -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

# Getting Active Directory Account Information


# To get more detailed information about an account, use GetDirectoryEntry() to turn the search result into actual account objects:


$searcher = [ADSISearcher]'(&(objectClass=User)(objectCategory=person)(SAMAccountName=*))'

$searcher.SizeLimit = 10

$searcher.FindAll() | ForEach-Object { $_.GetDirectoryEntry() } | Select-Object -Property * | Out-GridView

###########################################################################################################################################################################################

# Tip 69: Finding Current Script Folder


# Beginning in PowerShell 3.0, there is a very easy way of determining the folder a script is located in: $PSScriptRoot. 
# This variable always holds the folder path a given script is stored in.

# This way, it is simple to load additional resources like other scripts. 
# This code would load a second script called myFunctions.ps1 that is located in the same folder:

"$PSScriptRoot\myFunctions.ps1"

# Just don't forget to dot-source the path (the dot before the path). Else, the path name will be outputted (and not executed).

###########################################################################################################################################################################################

# Tip 70: Converting Binary SID to String SID


# Active Directory accounts contain the SID in binary form. To convert the byte array into a string representation, use a .NET function like this:

$searcher = [ADSISearcher]"(&(objectClass=User)(objectCategory=person)(SAMAccountName=$env:username))"
$user = $searcher.FindOne().GetDirectoryEntry() 
$user

$binarySID = $user.ObjectSid.Value
$stringSID = (New-Object System.Security.Principal.SecurityIdentifier($binarySID, 0)).Value

$binarySID
$stringSID    # Output: S-1-5-21-2146773085-903363285-719344707-1385424

# In this example, an ADSI searcher gets the current user account (provided the currently logged on user is logged on to a domain). Then, the binary SID is converted to a string SID.

# -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

$id = [System.Security.Principal.WindowsIdentity]::GetCurrent()                                  # get current user
$sid = $id.User.Value                                                                            # get the sid
$name = $id.User.Translate([System.Security.Principal.NTAccount])                                # get the ntaccount name
$binary = New-Object byte[] $id.User.BinaryLength                                                # get the sid as byte array
$id.User.GetBinaryForm($binary, 0)

# convert byte sid to string sid
$sid2 = (New-Object System.Security.Principal.SecurityIdentifier($binary, 0)).Value

# do the same with another account:
$account = New-Object System.Security.Principal.NTAccount($env:COMPUTERNAME, "Administrator")
$sid3 = $account.Translate([System.Security.Principal.SecurityIdentifier]).Value

###########################################################################################################################################################################################

# Tip 71: Getting Domain from DN


# A "DN" (Distinguished Name) is the path to an Active Directory object and could look similar to this:'CN=Tobias,OU=Authors,DC=powershell,DC=local'

$searcher = [ADSISearcher]"(&(objectClass=User)(objectCategory=person)(SAMAccountName=$env:username))"
$user = $searcher.FindOne().GetDirectoryEntry() 
$user

# Output:
#        distinguishedName : {CN=Silence,OU=UserAccounts,DC=domain,DC=corp,DC=company,DC=com}
#        Path              : LDAP://CN=Silence,OU=UserAccounts,DC=domain,DC=corp,DC=company,DC=com

# To get just the domain part of a DN, use code like this:

$DN = "CN=Silence,OU=UserAccounts,DC=domain,DC=corp,DC=company,DC=com"
$pattern = '(?i)DC=\w{1,}?\b'

# This piece of code uses a regular expression to find all DC= parts of a DN; then joins them together using a comma as delimiter.

([regex]::Matches($DN, $pattern) | ForEach-Object { $_.Value }) -join ","          # Output: DC=domain,DC=corp,DC=company,DC=com

###########################################################################################################################################################################################

# Tip 72: Searching in Different Domains


# When you use the ADSISearcher type accelerator to find Active Directory accounts, it defaults to the current domain you are logged on to. 
#　If you need to find an account in a different domain, make sure you define the search root accordingly.

# This example will find all accounts with a SamAccountName that starts with "tobias", and it searches the domain "powershell.local" (adjust to a real domain name, of course):

# get all users with a SamAccountName that starts with "tobias"
$searcher = [ADSISearcher]"(&(objectClass=User)(objectCategory=person)(sAMAccountName=tobias*))"

# use powershell.local for searching
$domain = New-Object System.DirectoryServices.DirectoryEntry('DC=powershell,DC=local')
$searcher.SearchRoot = $domain

# execute the query
$searcher.FindAll()                                                 # Exception here?

###########################################################################################################################################################################################

# Tip 73: Finding Active Directory Accounts by SID


# If you know the SID and would like to find the corresponding Active Directory account, then LDAP queries won't work well. 
# For them to work, you would have to reformat the SID to match the LDAP formatting rules which is not a trivial task.

# A much easier way uses an LDAP path. Let's assume you have a string SID in $SID variable, 
# and you would like to find the Active Directory account tied to it. Try this:

$id = [System.Security.Principal.WindowsIdentity]::GetCurrent()                                  # get current user
$sid = $id.User.Value  

$account = [ADSI]"LDAP://<SID=$sid>"
$account
$account.distinguishedName

# Output:
#        distinguishedName : {CN=Silence,OU=UserAccounts,DC=domain,DC=corp,DC=company,DC=com}
#        Path              : LDAP://<SID=S-1-5-21-****773085-90336****-71934***7-13***24>

###########################################################################################################################################################################################

# Tip 74: Finding Active Directory User Accounts Fast


# The more specific your LDAP query is the faster and less resource intense the query is, and the more precise are the results as well.

# For example, most people use objectClass to limit search results to a specific object class. 
# To find just user accounts, they often use "objectClass=user". It’s less known that computer accounts are also sharing this object class. Let's check it out:

$searcher = [ADSISearcher]"(&(objectClass=User)(SAMAccountName=S*))"

$result = Measure-Command {

    $all = $searcher.FindAll()
    $found = $all.Count
}

$seconds = $result.TotalSeconds
"The search returned $found objects and took $seconds seconds."    # Output: The search returned 1000 objects and took 41.1020961 seconds.


# Now use this line in the code above instead:


$searcher = [ADSISearcher]"(&(SAMAccountType=$(0x30000000))(SAMAccountName=S*))"

$result = Measure-Command {

    $all = $searcher.FindAll()
    $found = $all.Count
}

$seconds = $result.TotalSeconds
"The search returned $found objects and took $seconds seconds."    # Output: The search returned 1000 objects and took 20.4997637 seconds.

# When you replace this line, the query is significantly faster. And it is more precise, too. 
# That's because the sAMAccountType differentiates between regular user accounts and machine accounts:

# SAM_NORMAL_USER_ACCOUNT  0x30000000
# SAM_MACHINE_ACCOUNT      0x30000001 

# Both are of objectClass "User".


# Note: adsisearcher have the builtin limit of 1000 responses unless you specify different. 
# So if you have a "big" directory with lots of users, you might want to add the 

# $searcher.Pagesize = 1000 in the script.

# -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


# Getting More Than 1000 Active Directory Results

# By default, Active Directory returns only the first 1000 search results when you use an ADSISearcher. 
# This is a security mechanism designed to prevent unspecific LDAP queries from causing domain controller load.

# If you do need all search results and know that it will be more than 1000, make sure you set PageSize to 1000. 
# This way, ADSISearcher returns search results in chunks of 1000 elements.

# This query would return all user accounts in your domain (you may want to talk to your domain administrator before you actually run this query):

$searcher = [ADSISearcher]"SAMAccountType=$(0x30000000)"
$searcher.PageSize = 1000

$searcher.FindAll() | ForEach-Object { $_.GetDirectoryEntry() } | Select-Object -Property * | Out-GridView

###########################################################################################################################################################################################

# Tip 75: Hiding Parameters from IntelliSense


# Beginning with PowerShell 4.0, a script author can decide to hide function parameters from IntelliSense. 
# This way, less frequently used parameters can be omitted from ISE IntelliSense menus

function Test-Function
{
    param
    (
        $Name,

        [Parameter(DontShow)]
        [Switch]
        $IAmSecret
    )

    if($IAmSecret)
    {
        "Doing the secret things with the name."
    }
    else
    {
        "Regular behavior with $Name"
    }
}

# When you run this function in PowerShell 4.0 ISE, only "Name" will appear in the parameter IntelliSense list. 
# However, once you indicate that you know the hidden parameter, and start entering at least the first letter, then pressing (TAB) will show the parameter

# Hidden parameters will always be visible in the help window, which you could open like this:

help Test-Function -ShowWindow

###########################################################################################################################################################################################

# Tip 76: Finding Services in PowerShell


function Find-Service
{
    param
    (
        $Name = "*",
        $DisplayName = "*",
        $Started
    )

    $pattern = '^.*\.exe\b'

    $Name = $Name.Replace("*", "%")
    $DisplayName = $DisplayName.Replace("*", "%")

    Get-WmiObject -Class Win32_Service -Filter "Name like '$Name' and DisplayName like '$DisplayName'" | ForEach-Object {
    
        if($_.PathName -match $pattern)
        {
            $Path = $Matches[0].Trim('"')
            $file = Get-Item -Path $Path

            $rv = $_ | Select-Object -Property Name, DisplayName, isMicrosoft, Started, StartMode, Description, CompanyName, ProductName, 
                            FileDescription, ServiceType, ExitCode, InstallDate, DesktopInteract, ErrorControl, ExecutablePath, PathName

            $rv.CompanyName = $file.VersionInfo.CompanyName
            $rv.ProductName = $file.VersionInfo.ProductName
            $rv.FileDescription = $file.VersionInfo.FileDescription
            $rv.ExecutablePath = $path
            $rv.isMicrosoft = $file.VersionInfo.CompanyName -like "*Microsoft"

            $rv
        }
        else
        {
            Write-Warning ("Service {0} has no EXE attached. PathName = '{1}'" -f $_.PathName)
        }
    }
}

Find-Service | Out-GridView

###########################################################################################################################################################################################

# Tip 77: Replacing Specific Characters in a Text


# If you just need to replace characters anywhere in a text, you are easy off. This would capitalize every "l" in a text:

"Hello world".Replace("l","L")         # Output: HeLLo worLd

# Sometimes, however, you may want to replace individual character at a specific position. 
# Let's assume your text is a bit mask, and you want to set or clear a bit. This wouldn't work because it changes all bits at once:

"110100011110110".Replace("1", "0")                           # Output: 000000000000000
                                                              
"110100011110110"[-1] -eq "1"                                 # Output: False
"110100011110110"[-2] -eq "1"                                 # Output: True
                                                              
"110100011110110"[-2] = "0"                                   # Can't change string balue by index. Exception here: Unable to index into an object of type System.String

# To change individual characters in a string, convert it to a string builder:

$sb = New-Object System.Text.StringBuilder("110100011110110")

$sb[-1]                                                       # Output: 0
$sb[-1] -eq "1"                                               # Output: false
                                                              
$sb[-2] -eq "1"                                               # Output: true
$sb[-2] = "0"                                                 # update value by index
$sb[-2] -eq "1"                                               # Output: false, update success
                                                              
$sb.ToString()                                                # Output: 110100011110100


# convert a binary from string format to decimal format:

[System.Convert]::ToInt64($sb.ToString(), 2)                  # Output: 26868

###########################################################################################################################################################################################

# Tip 78: Dynamic Parameters in PowerShell 4.0


$list = 'AllUsersAllHosts','AllUsersCurrentHost','CurrentUserAllHosts','CurrentUserCurrentHost'

# Method One:
foreach($property in $list)
{
    $profile.$property
}

# Output:
#        C:\Windows\System32\WindowsPowerShell\v1.0\profile.ps1
#        C:\Windows\System32\WindowsPowerShell\v1.0\Microsoft.PowerShellISE_profile.ps1
#        C:\Users\sihe\Documents\WindowsPowerShell\profile.ps1
#        C:\Users\sihe\Documents\WindowsPowerShell\Microsoft.PowerShellISE_profile.ps1


# Method Two:
$list | ForEach-Object { $profile.$_ }


# This way, you could check and return all PowerShell profiles that are currently in use:
$list | ForEach-Object { $profile.$_ } | Where-Object { Test-Path $_ }


# Likewise, you can use Get-Member to first retrieve all properties present in a given object. 
# This would return all the properties found in PowerShell's "PrivateData" object that have "color" in their name:

$Host.PrivateData | Get-Member -Name *color* | Select-Object -ExpandProperty Name

# Next, you could get all the color settings in one line:

$object = $Host.PrivateData

$object | Get-Member -Name *color* -MemberType *property | ForEach-Object {

    $PropertyName = $_.Name
    $PropertyValue = $object.$PropertyName
    "$PropertyName = $PropertyValue"

} | Out-GridView

###########################################################################################################################################################################################

# Tip 79: Dynamic Methods in PowerShell 4


# Beginning with PowerShell 4.0, method names may come from variables. Here's a simple example:

$method = "ToUpper"
"Hello".$method()

# This can be useful when the method you want to use depends on something a script would need to figure out first.

function Convert-Text
{
    param
    (
        [Parameter(Mandatory = $true)]
        $Text,

        [Switch]$ToUpper
    )

    if($ToUpper)
    {
        $method = "ToUpper"
    }
    else
    {
        $method = "ToLower"
    }

    $text.$method()
}

# By default, the function would convert text to lower case. When the switch parameter -ToUpper is specified, 
# it converts the text to upper case instead. Thanks to dynamic methods, the function won't need separate code blocks for this.

# -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


# The solution for older Powershell version before 4.0

function Convert-Text2
{
    param
    (
        [Parameter(Mandatory = $true)]
        $Text,

        [Switch]$ToUpper
    )

    if($ToUpper)
    {
        $method = "ToUpper"
    }
    else
    {
        $method = "ToLower"
    }

    $Text.PSObject.Methods[$method].Invoke()
}

Convert-Text2 -Text "Hello" -ToUpper                        # Output: HELLO

###########################################################################################################################################################################################

# Tip 80: Finding Default Outlook Profile


$outlookApp = New-Object -ComObject Outlook.Application
$outlookApp.Application.DefaultProfileName                  # Output: Outlook

###########################################################################################################################################################################################

# Tip 81: Capitalizing Words


$sentence = 'here is some text where i would like the first letter to be capitalized.'

# Method One:
$pattern = '\b(\w)'
[Regex]::Replace($sentence, $pattern, { param($x) $x.Value.ToUpper() })   

# Output: Here Is Some Text Where I Would Like The First Letter To Be Capitalized.



# Method Two:
(Get-Culture).TextInfo.ToTitleCase($sentence)  # Output: Here Is Some Text Where I Would Like The First Letter To Be Capitalized.



# Regular expressions are more complicated but more versatile as well. 
# For example, if you wanted for some weird reason to replace the first letter of each word with its ASCII code, regular expressions can easily do:

$sentence = 'here is some text where i would like the first letter to be capitalized.'
$pattern = '\b(\w)'
[Regex]::Replace($sentence, $pattern, { param($x) [Byte][Char]$x.Value })

# Output: 104ere 105s 115ome 116ext 119here 105 119ould 108ike 116he 102irst 108etter 116o 98e 99apitalized.

###########################################################################################################################################################################################

# Tip 82: Exporting and Importing PowerShell History


# PowerShell keeps a list of all commands you enter, but once you close PowerShell, the list is lost. 

# Here is a simple one-liner that saves the current command history to file:
Get-History | Export-Clixml $env:temp\history.xml

# Once you start a new PowerShell console or ISE editor instance, you can load the saved history back into PowerShell:
Import-Clixml $env:temp\history.xml | Add-History


# Unfortunately, the loaded history will not influence the keyboard buffer, so pressing ARROWUP or ARROWDOWN won't show the newly imported history items. 
# However, you can use tab completion to find lines you entered before: (KEYWORD) <-Now press (TAB)!

###########################################################################################################################################################################################

# Tip 83: Getting Excuses Automatically


# Tired of inventing lame excuses yourself? Then here's a script that gets you a new excuse any time you call Get-Excuse! All you need is Internet access:

function Get-Excuse
{
    $ProgressPreference = "SilencelyContinue"

    $url = 'http://pages.cs.wisc.edu/~ballard/bofh/bofhserver.pl'
    $page = Invoke-WebRequest -Uri $url -UseBasicParsing

    $pattern = '<br><font size = "\+2">(.+)'

    if($page.Content -match $pattern)
    {
        $Matches[1]
    }
}

Get-Excuse

# If your Internet access goes through a proxy or needs authentication, 
# then look at the parameters of Invoke-WebRequest inside the function. You can submit proxy information as well as credentials.

###########################################################################################################################################################################################

# Tip 84: Finding Active Directory Users with Missing Mail Address


# LDAP queries are extremely powerful and can help find accounts that are missing information.

# This code would return all Active Directory users that actually have a mail address:
$searcher = [ADSISearcher]"(&(SAMAccountType=$(0x30000000))(mail=*))"
$searcher.FindAll() | ForEach-Object { $_.GetDirectoryEntry() } | Select-Object -Property SAMAccountName, Name, mail | Out-GridView


# If you want the opposite, negate the query using "!". This would return all Active Directory user accounts that currently have no mail address:
$searcher = [ADSISearcher]"(&(SAMAccountType=$(0x30000000))(!(mail=*)))"
$searcher.FindAll() | ForEach-Object { $_.GetDirectoryEntry() } | Select-Object -Property SAMAccountName, Name, mail | Out-GridView

###########################################################################################################################################################################################

# Tip 85: Press F1 to Navigate PowerShell Help Topics


# To get extensive help for all kinds of PowerShell operators in the PowerShell 3.0 ISE editor, first list all the different help topics about operators:

help operators

# Output: 
#        Name                          Category  Module     Synopsis                                                                                                                                       
#        ----                          --------  ------     --------                                                                                                                                       
#        about_Arithmetic_Operators    HelpFile             Describes the operators that perform arithmetic in Windows PowerShell.                                                                         
#        about_Assignment_Operators    HelpFile             Describes how to use operators to assign values to variables.                                                                                  
#        about_Comparison_Operators    HelpFile             Describes the operators that compare values in Windows PowerShell.                                                                             
#        about_Logical_Operators       HelpFile             Describes the operators that connect statements in Windows PowerShell.                                                                         
#        about_Operators               HelpFile             Describes the operators that are supported by Windows PowerShell.                                                                              
#        about_Type_Operators          HelpFile             Describes the operators that work with Microsoft .NET Framework types.   

# (If you do not see this list, you may have to first download PowerShell help. Take a look at Update-Help!)

# Next, click in any one of these topics, then press F1. The help window opens and displays detailed help.

###########################################################################################################################################################################################

# Tip 86: Monitoring Log Files


$path = "$home\Desktop\testfile.txt"

"Test" | Out-File $path
notepad $path

Get-Content -Path $path -Tail 0 -Wait | Out-GridView -Title $path

# This will create a test file on your desktop, and then open the file in the Notepad. PowerShell will then start monitoring the file. 
# Once you type new text into the Notepad window and save it, the changes will appear in a PowerShell grid view.

# Simply replace the path with any text-based log file you'd like to keep an eye on. Since PowerShell is blocked while it is monitoring the file, 
# you may want to execute the code in a separate PowerShell instance.

###########################################################################################################################################################################################

# Tip 87: Getting MAC Address Remotely


# Here is an easy way to get the MAC address, even from a remote machine:

getmac.exe /S 127.0.0.1 /FO CSV | ConvertFrom-Csv

# Output: 
#        Physical Address                Transport Name                                                                                            
#        ----------------                --------------                                                                                            
#        19-A8-07-B8-9B-D8               \Device\Tcpip_{C2CAEA6...} 

# Simply replace the IP address with the one you are interested in. You may need appropriate Admin privileges to access the information, of course.

###########################################################################################################################################################################################

# Tip 88: Installing Server 2012 Desktop Experience


# If you want to turn a Server 2012 (or Server 2008 R2) into a workstation machine and have it behave like Windows 8 
# (including the ability to burn ISO files from within File Explorer, and personalizing your desktop wallpapers and other settings),
# all you need to do is add the DesktopExperience feature. This is how you'd do it with PowerShell:

Add-WindowsFeature -Name Desktop-Experience

# In PowerShell 2.0, you first have to import the appropriate module manually:
Import-Module ServerManager

###########################################################################################################################################################################################

# Tip 89: Loading Modules Automatically


# Beginning with PowerShell 3.0, PowerShell is smart enough to know which cmdlets are exported by which extension module. 
# So you no longer have to know the module name and manually import it (using Import-Module). 
# Instead, auto-completion and IntelliSense will suggest every single command available from every module that is installed in one of the standard module folders. 
# Here's a method to list these standard folders:

$env:PSModulePath -split ";"

# Output:
#        C:\Users\sihe\Documents\WindowsPowerShell\Modules
#        C:\Windows\system32\WindowsPowerShell\v1.0\Modules\
#        C:\Program Files\Microsoft Security Client\MpProvider\
#        C:\Program Files (x86)\Microsoft SDKs\Windows Azure\PowerShell\

# The standard folders may vary, and you can add more folders to the environment variable if you want, 
# making modules available stored on USB sticks or external drives. This would add the path of a USB drive to your list, 
# so all modules stored in the folder specified would also be included automatically:

$env:PSModulePath += ";g:\mypersonalModules"

# ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

# Improving Module Auto-loading

# PowerShell 3.0 will auto-load modules as you have seen in a previous tip. However, with some modules, this technique may fail. 
# Their cmdlets will still only be available after you manually import the module using Import-Module.

# The reason most likely is the way these modules were built. PowerShell has no way of detecting which cmdlets are exported by these modules.
# Still, one simple line may help and make even more modules available automatically:

Get-Module -ListAvailable -Refresh

# The -Refresh switch parameter tells PowerShell to thoroughly look at all the modules available and build or refresh an internal command cache. 

###########################################################################################################################################################################################

# Tip 90: Listing "Real" Hard Drives


# WMI can provide lots of information about a system, but sometimes it is just a bit too much. 
# So when you query for logical disks, you often get back many more than just the physical ones.

# Setting an additional filter will do. This line returns only physical drives by making sure that only instances with a DriveType=3 are returned:

Get-WmiObject -Class Win32_LogicalDisk -Filter "DriveType=3"

# Output:
#        DeviceID     : C:
#        DriveType    : 3
#        ProviderName : 
#        FreeSpace    : 10396655616
#        Size         : 104752738304
#        VolumeName   : 
#        
#        DeviceID     : E:
#        DriveType    : 3
#        ProviderName : 
#        FreeSpace    : 373700026368
#        Size         : 395247087616
#        VolumeName   : New Volume

# Since Get-WmiObject has a parameter -ComputerName, you can get this information remotely as well. 
# And if you'd like to know what other drive types are there, simply remove the filter or visit a preferred search engine and search for "Win32_LogicalDisk DriveType".

Get-WmiObject -Class Win32_LogicalDisk

###########################################################################################################################################################################################

# Tip 91: Getting WMI IntelliSense


# Get-WmiObject provides no IntelliSense for WMI classes, so you either need to know the WMI class name off hand, or use the parameter -List to search for it.

# But there's a clever trick: Get-CimInstance does almost the same thing, 
# and its parameter -ClassName also accepts a WMI class name. And this parameter does provide IntelliSense support. 

Get-CimInstance -ClassName 

# Now press CTRL+SPACE to invoke IntelliSense. Have a look at the status bar, though. 
# There are hundreds of WMI class names, and on first try, IntelliSense may run in a timeout issue before it could gather all classes. 
# Over time, or when you limit the class name a bit, it will work though.

# So simply use Get-CimInstance instead of Get-WmiObject, then select the class name with full IntelliSense support, 
# now rename cmdlet and parameter back to Get-WmiObject -Class.

# Or, stick with Get-CimInstance in the first place. It returns basically the same wealth of information. 
# By default, however, it uses WSMan protocol for remoting rather than DCOM.

###########################################################################################################################################################################################

# Tip 92: Speeding Up Multiple WMI Queries


# Whenever you run Get-WmiObject against a remote system, it will create a new connection. 
# So if you query different WMI classes, each query will use its own connection, which slows down overall performance.

# Beginning with PowerShell 3.0, there is a new set of cmdlets. 
# With these cmdlets it is easy to reuse an existing connection to efficiently run multiple queries:

$session = New-CimSession -ComputerName localhost
$os = Get-CimInstance -ClassName Win32_OperatingSystem -CimSession $session
$bios = Get-CimInstance -ClassName Win32_BIOS -CimSession $session

# The session by default uses WSMAN:
$session

# Output:
#        Id           : 1
#        Name         : CimSession1
#        InstanceId   : 81226b64-1cb2-4400-a67d-b3b8ad1b7463
#        ComputerName : localhost
#        Protocol     : WSMAN


# When you create the session, you can specify a different remoting protocol as well, like DCOM.


$os

# Output:
#        SystemDirectory   Organization     BuildNumber      RegisteredUser   SerialNumber     Version     PSComputerName
#        ---------------   ------------     -----------      --------------   ------------     -------     --------------
#        D:\Windows\sys...  Corp            7601             ASI User         00496-164-240... 6.1.7601    localhost


$bios

# Output:
#        SMBIOSBIOSVersion : 090004
#        Manufacturer      : American Megatrends Inc.
#        Name              : BIOS Date: 03/19/09 22:51:32  Ver: 09.00.04
#        SerialNumber      : 3427-0776-9473-3189-1048-0490-62
#        Version           : VRTUAL - 3000919
#        PSComputerName    : localhost

###########################################################################################################################################################################################

# Tip 93: Accessing All Users Desktop


# Resolve-Path is an excellent cmdlet to find paths that have the same nesting level. 
# For example, here's a really short script that creates a text file on the desktop for all users of your machine:

$root = Split-Path $env:userprofile

Resolve-Path $root\*\Decktop | ForEach-Object {

    $path = Join-Path -Path $_ -ChildPath "hello.txt"

    "Here is some content ..." | Out-File -FilePath $path

    Write-Warning "Creating $path"
}

# Provided your script has Administrator privileges, it will add the file to all desktops for all users that have a user profile on your machine

###########################################################################################################################################################################################

# Tip 94: Executing Code Remotely


# In a domain environment, PowerShell remoting is working almost out of the box. 
# All you might have to do is enable Remoting on target machines (beginning with Server 2012, PowerShell remoting is enabled by default for Administrators).

# In PowerShell 3.0, to enable remoting manually, that's all (Administrator privileges required):

Enable-PSRemoting -SkipNetworkProfileCheck -Force

# You do not need to configure anything on the client side (the machine that is going to send commands).

# Next, any Administrator can send PowerShell code to the enabled machine and have it execute. 
# This example would list all the PowerShell-related processes from the target machine:

$code = {

    Get-Process -Name powershell*,wsmprovhost -ErrorAction SilentlyContinue
}

$list = 'server1', 'server2', 'server3'

Invoke-Command -ScriptBlock $code -ComputerName $list

# It reports all running instances of the PowerShell console, the ISE PowerShell editor, 
# and any hidden PowerShell remoting sessions initiated from someone else on your machine.


# Once you uncomment the -ComputerName parameter, the code will run on all of the machines listed in $list variable.
# Make sure they exist and have remoting enabled. When you receive data from remote computers, 
# PowerShell automatically adds a "PSComputerName" property with the name of the computer that sent back the information.

###########################################################################################################################################################################################

# Tip 95: Getting DLL File Version Info


# Ever needed a list of DLL files and their versions? Get-ChildItem can get this information for you. You just need to unpack some properties like so:

Get-ChildItem C:\Windows\System32\*.dll | Select-Object -ExpandProperty VersionInfo | Select-Object -Property FileName, ProductVersion, ProductName

# This actually replaces (-ExpandProperty) the original FileInfo object with the VersionInfo object found within. 
# You basically exchange one object for another one, and lose access to the information held in the first. 
# For example, you no longer have access to properties like LastWriteTime.

Get-ChildItem C:\Windows\System32\*.dll | Select-Object -ExpandProperty VersionInfo | Select-Object -Property LastWriteTime   # null for LastWriteTime

# If you'd rather want to keep the original FileInfo object, but add some additional information from inside, use Add-Member like this:

Get-ChildItem C:\Windows\System32\*.dll | Add-Member -MemberType ScriptProperty -Name Version -Value { $this.VersionInfo.ProductVersion } -PassThru | 
    Select-Object -Property LastWriteTime, Length, Name, Version | Out-GridView

# "$this" is the object you are extending. 

###########################################################################################################################################################################################

# Tip 96: Finding Known USB Drives


# Did you know that Windows maintains a list of all USB storage devices ever hooked up to your machine? And it's simple to dump that list:

$path = "HKLM:\SYSTEM\CurrentControlSet\Enum\USBSTOR\*\*"

Get-ItemProperty -Path $path | Select-Object -Property FriendlyName, CompatibleIDs, Mgf

# The longer the list, the more different USB storage device contacts did your computer have.

###########################################################################################################################################################################################

# Tip 97: Getting Folders by Prefix


Get-ChildItem -Path C:\Windows -Directory | Group-Object -Property { $_.Name.PadRight(3).Substring(0,3) }

# Output:
#        Count Name                      Group                                                                                                                                                                                
#        ----- ----                      -----                                                                                                                                                                                
#            1 %LO                       {%LOCALAPPDATA%}                                                                                                                                                                     
#            1 add                       {addins}                                                                                                                                                                             
#            2 App                       {AppCompat, AppPatch}                                                                                                                                                                
#            1 ass                       {assembly}                                                                                                                                                                           
#            1 Boo                       {Boot}                                                                                                                                                                               
#            1 Bra                       {Branding}   
#        .................................................                                                                                                                                                                                

$lookup = Get-ChildItem -Path $env:windir -Directory | Group-Object -Property { $_.Name.PadRight(3).Substring(0,3).ToUpper() } -AsHashTable -AsString
$lookup.Keys

# Output:
#        WIN
#        DIA
#        DIG
#        PER
#        PLA
#        ...

# So now it is really trivial to get all folders that, let's say, start with "SYS":

$lookup.SYS

# Output:
#        Mode                LastWriteTime     Length Name                                                                                                                                                                    
#        ----                -------------     ------ ----                                                                                                                                                                    
#        d----        2009/07/14  10:36 AM            system                                                                                                                                                                  
#        d----        2014/11/19  12:02 PM            System32                                                                                                                                                                
#        d----        2014/11/19  12:02 PM            SysWOW64 

###########################################################################################################################################################################################

# Tip 98: Create a Folder Selector


# To add a little glamour to your scripts, here are a few lines of code that display a folder selector dialog. 
# When a user selects a folder, your script receives the selection and can work with the selected path:

Add-Type -AssemblyName System.Windows.Forms
[System.Windows.Forms.Application]::EnableVisualStyles()

$folderBrowser = New-Object System.Windows.Forms.FolderBrowserDialog
$null = $folderBrowser.ShowDialog()
$path = $folderBrowser.SelectedPath

"You selected: $Path"

# Note the first two lines: they are not necessary when you run the code inside the ISE editor, 
# but you do need them inside the powershell.exe. So keep these lines to make sure your code runs in all PowerShell hosts.

###########################################################################################################################################################################################

# Tip 99: Obfuscating Credentials


$cred = Get-Credential
$username = $cred.UserName
$password = $cred.Password

$key = 1..32 | ForEach-Object { Get-Random -Maximum 256 }
$passwordEncrypted = $password | ConvertFrom-SecureString -Key $key

$secret = -join ($key | ForEach-Object { "{0:x2}" -f $_ })
$secret += $passwordEncrypted

# Create Code
$code  = '$i = ''{0}'';' -f $secret 
$code += '$cred = New-Object PSCredential(''' 
$code += $username + ''', (ConvertTo-SecureString $i.SubString(64)'
$code += ' -k ($i.SubString(0,64) -split "(?<=\G[0-9a-f]{2})(?=.)" |'
$code += ' % { [Convert]::ToByte($_,16) })))'

# Write new script
$editor = $psISE.CurrentPowerShellTab.Files.Add().Editor
$editor.InsertText($code)
$editor.SetCaretPosition(1, 1)

# New Script like below:
$i = 'd282c0247e1ef4c8a6621629cdda09298f390caf2c274098efaef05ad95e2af876492d1116743f0423413b16050a5345MgB8ADYATgA3AGYAZAB6AHgAbwBKAEsAMABBAFgAcQBCADEASAB5AFEAagB0AGcAPQA9AHwAOAA1AD
      IAYwAzADcAOABmAGMAYwA3ADgANAAzAGEAOAA5ADAAMQAzAGMAZAA4AGIAZABhADkAZQBlAGIAOAAzADMAYgA5ADMANgBhAGQAMAA3ADUANgA4ADQANABhADgAMQA3ADQAMAA2AGQAMABhADcAMABkAGYAMQAyAGUANgA=';

$cred = New-Object PSCredential('FAREAST\v-sihe', (ConvertTo-SecureString $i.SubString(64) -k ($i.SubString(0,64) -split "(?<=\G[0-9a-f]{2})(?=.)" | % { [Convert]::ToByte($_,16) })))

$cred 
# Output:
#        UserName                                                    Password
#        --------                                                    --------
#        FAREAST\v-sihe                          System.Security.SecureString

# The cryptic auto-generated script code will define the variable $cred, which will hold a valid credential including the password. 
# You can then use $cred inside of your script wherever a -Credential parameter wants a username and password from you.

###########################################################################################################################################################################################

# Tip 100: Creating Temporary Password


# Here's a chunk of code that creates random passwords of different lengths for you:

$length = 8
$characters = [char[]]((31..50) + (65..90) + (97..122))
$characters = $characters -ne "O" -ne "o" -ne "l" -ne "1" -ne "-"     # new trick here
$password = -join ($characters | Get-Random -Count $length)

"Your temporary $length-character-password is $password" 

# The password length is set by $length. The characters used to compose the passwords are defined in $characters. 
# By default, all ASCII codes from 31-50, 65-90, and 97-122 are used. As you can see, with the -ne operator, you can fine-tune the list and exclude characters. 
# In our example, we exclude characters that can easily be misinterpreted.

###########################################################################################################################################################################################